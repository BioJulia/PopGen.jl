{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This is the documentation for the PopGen.jl package. If you're here, you're likely interested in doing some kind of population genetics analyses. Please read through the docs and try the functions out with the test data to get a feel for what PopGen.jl can do. About PopGen.jl is an attempt to shift population genetics analyses away from the patchwork of available pop-gen packages present in the R and Python languages, and combine it with the speed, power, fun(?), and community of the Julia language. We hope to implement common analyses (heterozygosity, kinship, FST, Tajima's D, etc.) in sane , user friendly ways, with syntax used within the package being consistent with the rest of the Julia ecosystem. Goal To be a comprehensive package for population genetics analyses and visualization that's fast and user friendly. This project is developed with a particular mantra: Sanity, Sensibility, Accessibility . Sanity Functions are written in a way such that their use is sane and natural. When possible (or sensible), we use full words for input variables or other components of input/output. All functions in this package have their first argument as the input data without keywords. Always. We also try to minimize redundancy, such as the function remove_loci! , where the loci you wish you remove are listed as the second argument without a keyword, because the name of the function is already self explanatory, and the first argument will always be the input data, therefor having a keyword argument loci = would be redundant. Sensibility Functions need to be sensible, both in what they do and how they do it. This means that functions should include only the most relevant arguments, and the most sensible defaults for arguments. It also means the outputs need to be flexible enough to use with other Julia packages. As an example, plot_missing takes the entire PopObj as an argument rather than a user specifying specific elements, and it returns a pre-configured plot for basic data visualization. The only arguments are a custom color palette, if so desired. However, the purpose of that plot is for data exploration, so the specification of plotting attributes is unnecessary because those plots will never be in publications. If a user wants to make their own plots using that information, they can do that with the dataframes produced from missing , which is exactly what plot_missing does under the hood! Accessibility Documentation is everything! We recognize Julia is a comparatively young language, and we know which languages and packages other population geneticists are using for their work. We want you to be comfortable using PopGen.jl, and that means investing a lot of time into writing thorough documentation intended for users (vs developers). We also recognize that you (the reader) might not be very familiar with Julia, or any language other than R (which is ok!), so we've written a section on clarifying some Julia concepts/conventions that will make reading this documentation a whole lot clearer. It is by no means a replacement for sitting down and learning the Julia language a bit ( here is a great online book on that ), but it should hopefully reduce the barrier of entry somewhat. Why Julia (and not Python or R)? Speed and syntax The speed is comparable to C when coded correctly. Also, has Python-like syntax with optional tabs. We are also fans of 1-indexing, but that's more of a perk. A modern language for modern problems Julia has native support for: parallelization, distributed computing, GPU processing, and pipes! It also has robust machine learning packages (maybe for future implementations). Community & contribution Julia's just-in-time type-safe and optimized compiling solves what's known as the \"two language problem\". That is, languages that are easy to write in (e.g. Python, R, Ruby) are slow compared to languages that are more difficult to write in, which are fast (e.g. C, C++, Java). For languages that are easier to write in, many of the commonly used packages and functions in those languages are written in another, faster language under the hood for performance reasons. On the whole, that's not really a problem for end-users, because functions work and they are easy to use. But , it does become a problem when you want to investigate the code and implementation of a function. This means that, even as an R power-user, you are powerless to investigate the implementation of something you are using in R if it's actually written in C++ under the hood. In a sense, it makes the publications of those methods less reproducible, because the users of it may be familiar with the language it's deployed in (like R), but not the language it's written in, (like C++). What if there are bugs?! What if the code implementation doesn't match the formulations in the publication?! Yikes! And thus solving the two language problem, users can themselves diagnose these things if they so choose. Yes, that means that we might be getting more Issues opened up, but a bug found is a lot better than a bug overlooked! Like most Julia packages, PopGen.jl is written entirely in Julia, meaning the community using it need not learn another language if they wanted to contribute! Have you written a clever Julia function to calculate SAMOVA from a PopObj ? Send us a pull request (please!)! Or join the Slack! Package manager Which, let's be honest, is such a delight to use. Installing PopGen.jl should be simple, consistent, and effortless thanks to the brilliant built-in package manager in Julia. Authors Pavel Dimens, PhD Student @ U. Southern Mississippi Jason Selwyn, PhD Candidate @ Texas A&M University - Corpus Christi","title":"Home"},{"location":"#about","text":"PopGen.jl is an attempt to shift population genetics analyses away from the patchwork of available pop-gen packages present in the R and Python languages, and combine it with the speed, power, fun(?), and community of the Julia language. We hope to implement common analyses (heterozygosity, kinship, FST, Tajima's D, etc.) in sane , user friendly ways, with syntax used within the package being consistent with the rest of the Julia ecosystem.","title":"About"},{"location":"#goal","text":"To be a comprehensive package for population genetics analyses and visualization that's fast and user friendly. This project is developed with a particular mantra: Sanity, Sensibility, Accessibility . Sanity Functions are written in a way such that their use is sane and natural. When possible (or sensible), we use full words for input variables or other components of input/output. All functions in this package have their first argument as the input data without keywords. Always. We also try to minimize redundancy, such as the function remove_loci! , where the loci you wish you remove are listed as the second argument without a keyword, because the name of the function is already self explanatory, and the first argument will always be the input data, therefor having a keyword argument loci = would be redundant. Sensibility Functions need to be sensible, both in what they do and how they do it. This means that functions should include only the most relevant arguments, and the most sensible defaults for arguments. It also means the outputs need to be flexible enough to use with other Julia packages. As an example, plot_missing takes the entire PopObj as an argument rather than a user specifying specific elements, and it returns a pre-configured plot for basic data visualization. The only arguments are a custom color palette, if so desired. However, the purpose of that plot is for data exploration, so the specification of plotting attributes is unnecessary because those plots will never be in publications. If a user wants to make their own plots using that information, they can do that with the dataframes produced from missing , which is exactly what plot_missing does under the hood! Accessibility Documentation is everything! We recognize Julia is a comparatively young language, and we know which languages and packages other population geneticists are using for their work. We want you to be comfortable using PopGen.jl, and that means investing a lot of time into writing thorough documentation intended for users (vs developers). We also recognize that you (the reader) might not be very familiar with Julia, or any language other than R (which is ok!), so we've written a section on clarifying some Julia concepts/conventions that will make reading this documentation a whole lot clearer. It is by no means a replacement for sitting down and learning the Julia language a bit ( here is a great online book on that ), but it should hopefully reduce the barrier of entry somewhat.","title":"Goal"},{"location":"#why-julia-and-not-python-or-r","text":"","title":"Why Julia (and not Python or R)?"},{"location":"#speed-and-syntax","text":"The speed is comparable to C when coded correctly. Also, has Python-like syntax with optional tabs. We are also fans of 1-indexing, but that's more of a perk.","title":"Speed and syntax"},{"location":"#a-modern-language-for-modern-problems","text":"Julia has native support for: parallelization, distributed computing, GPU processing, and pipes! It also has robust machine learning packages (maybe for future implementations).","title":"A modern language for modern problems"},{"location":"#community-contribution","text":"Julia's just-in-time type-safe and optimized compiling solves what's known as the \"two language problem\". That is, languages that are easy to write in (e.g. Python, R, Ruby) are slow compared to languages that are more difficult to write in, which are fast (e.g. C, C++, Java). For languages that are easier to write in, many of the commonly used packages and functions in those languages are written in another, faster language under the hood for performance reasons. On the whole, that's not really a problem for end-users, because functions work and they are easy to use. But , it does become a problem when you want to investigate the code and implementation of a function. This means that, even as an R power-user, you are powerless to investigate the implementation of something you are using in R if it's actually written in C++ under the hood. In a sense, it makes the publications of those methods less reproducible, because the users of it may be familiar with the language it's deployed in (like R), but not the language it's written in, (like C++). What if there are bugs?! What if the code implementation doesn't match the formulations in the publication?! Yikes! And thus solving the two language problem, users can themselves diagnose these things if they so choose. Yes, that means that we might be getting more Issues opened up, but a bug found is a lot better than a bug overlooked! Like most Julia packages, PopGen.jl is written entirely in Julia, meaning the community using it need not learn another language if they wanted to contribute! Have you written a clever Julia function to calculate SAMOVA from a PopObj ? Send us a pull request (please!)! Or join the Slack!","title":"Community &amp; contribution"},{"location":"#package-manager","text":"Which, let's be honest, is such a delight to use. Installing PopGen.jl should be simple, consistent, and effortless thanks to the brilliant built-in package manager in Julia.","title":"Package manager"},{"location":"#authors","text":"Pavel Dimens, PhD Student @ U. Southern Mississippi Jason Selwyn, PhD Candidate @ Texas A&M University - Corpus Christi","title":"Authors"},{"location":"PopObj_accessing/","text":"A little hands-on training will probably go a long way, so let's through some of the functions available in PopGen.jl with the included data. This tutorial will include both inputs and outputs so you can be confident what you're seeing in your Julia session is exactly what's supposed to happen. Sometimes the outputs can be a little lengthy, so they will be arranged in code \"tabs\", where the left-most tab is the input named after what it's accomplishing, and the right tab is the output of running the command. Loading in the data Let's keep things simple by loading in the nancycats data and calling it ncats load nancycats julia > ncats = nancycats () ; summary ( ncats ) output Object of type PopObj: Longitude: Any[missing, missing, missing, missing, missing, missing] \u2026 Any[missing, missing, missing, missing, missing, missing] Latitude: Any[missing, missing, missing, missing, missing, missing] \u2026 Any[missing, missing, missing, missing, missing, missing] Number of individuals: 237 [\"N215\", \"N216\", \"N217\"] \u2026 [\"N281\", \"N289\", \"N290\"] Number of loci: 9 [\"fca23\", \"fca37\", \"fca43\"] \u2026 [\"fca8\", \"fca90\", \"fca96\"] Ploidy: Int8[2, 2, 2] \u2026 Int8[2, 2, 2] Number of populations: 17 #samp_id | Pop -------------- 10 | 1 22 | 2 12 | 3 23 | 4 15 | 5 11 | 6 14 | 7 10 | 8 9 | 9 11 | 10 20 | 11 14 | 12 13 | 13 17 | 14 11 | 15 12 | 16 13 | 17 Available .samples fields: .name, .population, .ploidy, .longitude, .latitude Note the last line of the output. These samples fields can be accessed by name using the dot . accessor. Now that we have nancycats loaded in, we can use standard Julia accessor conventions to view the elements within our PopObj. samples .samples To view the entire samples dataframe .samples julia > ncats . samples output 237 \u00d75 DataFrames . DataFrame \u2502 Row \u2502 name \u2502 population \u2502 ploidy \u2502 longitude \u2502 latitude \u2502 \u2502 \u2502 String \u2502 Categorical\u2026\u2370 \u2502 Int8 \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 N215 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 2 \u2502 N216 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 3 \u2502 N217 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 4 \u2502 N218 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 5 \u2502 N219 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 6 \u2502 N220 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 7 \u2502 N221 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 8 \u2502 N222 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 9 \u2502 N223 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 10 \u2502 N224 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 11 \u2502 N7 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 12 \u2502 N141 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 13 \u2502 N142 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 14 \u2502 N143 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 15 \u2502 N144 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 16 \u2502 N145 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 17 \u2502 N146 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u22ee \u2502 220 \u2502 N258 \u2502 \"16\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 221 \u2502 N259 \u2502 \"16\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 222 \u2502 N260 \u2502 \"16\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 223 \u2502 N261 \u2502 \"16\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 224 \u2502 N262 \u2502 \"16\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 225 \u2502 N282 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 226 \u2502 N283 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 227 \u2502 N288 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 228 \u2502 N291 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 229 \u2502 N292 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 230 \u2502 N293 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 231 \u2502 N294 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 232 \u2502 N295 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 233 \u2502 N296 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 234 \u2502 N297 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 235 \u2502 N281 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 236 \u2502 N289 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 237 \u2502 N290 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 .name This will access the names of the individuals as they appeared in the data. .ind julia > ncats . samples . name output 237-element Array{String,1}: \"N215\" \"N216\" \"N217\" \"N218\" \"N219\" \"N220\" \"N221\" \"N222\" \"N223\" \"N224\" \"N7\" \"N141\" \"N142\" \"N143\" \"N144\" \"N145\" \"N146\" \"N147\" \"N148\" \"N149\" \u22ee \"N256\" \"N257\" \"N258\" \"N259\" \"N260\" \"N261\" \"N262\" \"N282\" \"N283\" \"N288\" \"N291\" \"N292\" \"N293\" \"N294\" \"N295\" \"N296\" \"N297\" \"N281\" \"N289\" \"N290\" .population This will access the names of the populations associated with each individual, in the same order as the individuals. .popid julia > ncats . population output 237-element Array{Union{Int64, String},1}: \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \u22ee \"16\" \"16\" \"16\" \"16\" \"16\" \"16\" \"16\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" These ID's aren't super informative. Later, we'll change them using the popid! command. .ploidy This shows you the ploidy of the data per individual. .ploidy julia > ncats . samples . ploidy output 237-element Array{Int8,1}: 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \u22ee 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 .latitude This accesses the latitude information of the PopObj. If there is none, like in the nancycats data, it returns an empty array. .latitude julia > ncats . samples . latitude output 237-element Array{Any,1}: missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing \u22ee missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing .longitude This accesses the longitude information of the PopObj. Like before, iIf there is none, like in the nancycats data, it returns an empty array. .longitude julia > ncats . samples . longitude output 237-element Array{Any,1}: missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing \u22ee missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing Seeing some location info The nancycats data has some weird coordinate system for information, so those data were omitted. If you want a proof of concept for .longitude and .latitude , load in gulfsharks and try it out. We'll use hcat (horizontal concatination) to horizontally bind the individual names, their latitude, and longitude. Later, you'll see that the locations command does this and a bit more. load gulfsharks julia > sharks = gulfsharks () ; # semicolon just supresses printing output julia > hcat ( sharks . samples . name , sharks . samples . latitude , sharks . samples . longitude ) output 212\u00d73 Array{Any,2}: \"cc_001\" 28.3062 -80.5993 \"cc_002\" 28.3079 -80.5995 \"cc_003\" 28.3023 -80.5996 \"cc_005\" 28.6123 -80.4225 \"cc_007\" 27.8666 -80.3578 \"cc_008\" 27.8666 -80.3579 \"cc_009\" 27.8682 -80.3482 \"cc_010\" 27.8711 -80.3482 \"cc_012\" 28.4815 -80.4303 \"cc_013\" 28.2421 -80.2494 \"cc_014\" 28.2428 -80.2496 \"cc_015\" 28.2378 -80.2496 \"cc_016\" 28.2414 -80.2498 \"cc_017\" 28.236 -80.2495 \"cc_018\" 28.2364 -80.2494 \"cc_019\" 28.3906 -80.4963 \"cc_020\" 28.3902 -80.4968 \"cc_021\" 28.3861 -80.4967 \"cc_022\" 28.3869 -80.4966 \"cc_023\" 28.3865 -80.496 \u22ee \"seg_001\" 29.8901 -87.7189 \"seg_003\" 30.1943 -88.0007 \"seg_009\" 30.0021 -88.0493 \"seg_010\" 30.0069 -88.049 \"seg_011\" 29.8362 -88.1675 \"seg_012\" 29.5057 -88.0546 \"seg_014\" 30.1428 -88.2974 \"seg_015\" 30.2074 -88.36 \"seg_016\" 30.1151 -88.3922 \"seg_018\" 29.8362 -88.168 \"seg_021\" 29.9466 -86.0399 \"seg_023\" 29.9969 -85.6494 \"seg_024\" 29.6966 -87.4403 \"seg_025\" 30.064 -86.5374 \"seg_026\" 30.0696 -86.5376 \"seg_027\" 29.9065 -86.0905 \"seg_028\" 30.0532 -87.3661 \"seg_029\" 30.0522 -87.3662 \"seg_030\" 29.8234 -85.7143 \"seg_031\" 29.8234 -85.7143 \u200b``` loci .loci This will show you the entire loci dataframe .loci julia > ncats . loci output 237\u00d79 DataFrames.DataFrame. Omitted printing of 2 columns \u2502 Row \u2502 fca23 \u2502 fca37 \u2502 fca43 \u2502 fca45 \u2502 fca77 \u2502 fca78 \u2502 fca8 \u2502 \u2502 \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 (136, 146) \u2502 (208, 208) \u2502 (139, 139) \u2502 (116, 120) \u2502 (156, 156) \u2502 (142, 148) \u2502 missing \u2502 \u2502 2 \u2502 (146, 146) \u2502 (208, 208) \u2502 (139, 145) \u2502 (120, 126) \u2502 (156, 156) \u2502 (142, 148) \u2502 missing \u2502 \u2502 3 \u2502 (136, 146) \u2502 (210, 210) \u2502 (141, 141) \u2502 (116, 116) \u2502 (152, 156) \u2502 (142, 142) \u2502 (135, 143) \u2502 \u2502 4 \u2502 (138, 138) \u2502 (208, 208) \u2502 (139, 141) \u2502 (116, 126) \u2502 (150, 150) \u2502 (142, 148) \u2502 (133, 135) \u2502 \u2502 5 \u2502 (140, 146) \u2502 (208, 208) \u2502 (141, 145) \u2502 (126, 126) \u2502 (152, 152) \u2502 (142, 148) \u2502 (133, 135) \u2502 \u2502 6 \u2502 (136, 146) \u2502 (208, 208) \u2502 (145, 149) \u2502 (120, 126) \u2502 (150, 156) \u2502 (148, 148) \u2502 (135, 143) \u2502 \u2502 7 \u2502 (136, 146) \u2502 (208, 208) \u2502 (139, 145) \u2502 (116, 126) \u2502 (152, 152) \u2502 (142, 148) \u2502 (135, 135) \u2502 \u2502 8 \u2502 (136, 146) \u2502 (208, 212) \u2502 (135, 149) \u2502 (120, 126) \u2502 (154, 158) \u2502 (142, 148) \u2502 (135, 143) \u2502 \u2502 9 \u2502 (136, 146) \u2502 (208, 212) \u2502 (139, 139) \u2502 (116, 126) \u2502 (150, 160) \u2502 (142, 142) \u2502 (137, 143) \u2502 \u2502 10 \u2502 (132, 132) \u2502 (208, 208) \u2502 (141, 145) \u2502 (120, 126) \u2502 (150, 156) \u2502 (148, 148) \u2502 (135, 135) \u2502 \u2502 11 \u2502 (130, 136) \u2502 (182, 182) \u2502 (137, 145) \u2502 (128, 128) \u2502 (152, 152) \u2502 (142, 150) \u2502 (137, 141) \u2502 \u2502 12 \u2502 (130, 136) \u2502 (182, 208) \u2502 (135, 145) \u2502 (126, 128) \u2502 (144, 150) \u2502 (140, 140) \u2502 (129, 133) \u2502 \u2502 13 \u2502 (130, 130) \u2502 (208, 208) \u2502 (135, 145) \u2502 (128, 130) \u2502 (152, 156) \u2502 (142, 142) \u2502 (129, 133) \u2502 \u2502 14 \u2502 (130, 136) \u2502 (182, 206) \u2502 (135, 135) \u2502 (128, 130) \u2502 (156, 156) \u2502 (142, 142) \u2502 (133, 133) \u2502 \u2502 15 \u2502 (136, 136) \u2502 (208, 208) \u2502 (137, 137) \u2502 (126, 130) \u2502 (152, 152) \u2502 (140, 142) \u2502 (131, 135) \u2502 \u2502 16 \u2502 (136, 146) \u2502 (182, 192) \u2502 (135, 135) \u2502 (128, 130) \u2502 (144, 144) \u2502 (142, 142) \u2502 (129, 135) \u2502 \u2502 17 \u2502 (130, 144) \u2502 (182, 192) \u2502 (133, 133) \u2502 (126, 126) \u2502 (144, 144) \u2502 (140, 140) \u2502 (129, 133) \u2502 \u22ee \u2502 220 \u2502 (136, 140) \u2502 (208, 208) \u2502 (139, 145) \u2502 (122, 126) \u2502 (144, 152) \u2502 (142, 150) \u2502 (137, 139) \u2502 \u2502 221 \u2502 (136, 140) \u2502 (206, 208) \u2502 (145, 149) \u2502 (126, 126) \u2502 (152, 152) \u2502 (142, 142) \u2502 (137, 143) \u2502 \u2502 222 \u2502 (136, 136) \u2502 (210, 210) \u2502 (145, 149) \u2502 (122, 126) \u2502 (152, 152) \u2502 (150, 150) \u2502 (135, 139) \u2502 \u2502 223 \u2502 (136, 136) \u2502 (208, 208) \u2502 (145, 145) \u2502 (122, 126) \u2502 (152, 156) \u2502 (142, 142) \u2502 (139, 143) \u2502 \u2502 224 \u2502 (136, 140) \u2502 (208, 208) \u2502 (149, 149) \u2502 (120, 126) \u2502 (152, 152) \u2502 (142, 150) \u2502 (135, 139) \u2502 \u2502 225 \u2502 (136, 138) \u2502 (208, 208) \u2502 (135, 139) \u2502 missing \u2502 (150, 156) \u2502 (142, 150) \u2502 (133, 135) \u2502 \u2502 226 \u2502 (136, 136) \u2502 (182, 182) \u2502 (135, 139) \u2502 missing \u2502 (146, 156) \u2502 (142, 142) \u2502 (133, 135) \u2502 \u2502 227 \u2502 (136, 136) \u2502 (182, 208) \u2502 (135, 139) \u2502 missing \u2502 (150, 156) \u2502 (142, 150) \u2502 (133, 141) \u2502 \u2502 228 \u2502 (130, 146) \u2502 (208, 208) \u2502 (141, 141) \u2502 missing \u2502 (148, 156) \u2502 (142, 150) \u2502 (133, 141) \u2502 \u2502 229 \u2502 (138, 138) \u2502 (208, 208) \u2502 (141, 145) \u2502 missing \u2502 (148, 156) \u2502 (142, 142) \u2502 (123, 133) \u2502 \u2502 230 \u2502 (138, 138) \u2502 (208, 208) \u2502 (139, 139) \u2502 missing \u2502 (150, 156) \u2502 (142, 142) \u2502 (123, 133) \u2502 \u2502 231 \u2502 (136, 146) \u2502 (208, 208) \u2502 (139, 139) \u2502 missing \u2502 (150, 150) \u2502 (142, 148) \u2502 (133, 141) \u2502 \u2502 232 \u2502 (130, 136) \u2502 (208, 208) \u2502 (139, 145) \u2502 missing \u2502 (152, 158) \u2502 (142, 142) \u2502 (133, 141) \u2502 \u2502 233 \u2502 (136, 146) \u2502 (208, 220) \u2502 (139, 145) \u2502 missing \u2502 (150, 158) \u2502 (142, 148) \u2502 (133, 141) \u2502 \u2502 234 \u2502 (130, 130) \u2502 (208, 208) \u2502 (135, 145) \u2502 missing \u2502 (148, 156) \u2502 (142, 142) \u2502 (133, 143) \u2502 \u2502 235 \u2502 (136, 144) \u2502 (208, 208) \u2502 (143, 143) \u2502 missing \u2502 (144, 150) \u2502 (142, 150) \u2502 (135, 141) \u2502 \u2502 236 \u2502 (130, 136) \u2502 (208, 208) \u2502 (135, 145) \u2502 missing \u2502 (150, 150) \u2502 (142, 142) \u2502 (137, 143) \u2502 \u2502 237 \u2502 (130, 146) \u2502 (208, 208) \u2502 (135, 139) \u2502 missing \u2502 (150, 156) \u2502 (142, 150) \u2502 (135, 141) \u2502 locus names This will access the names of the loci as they appeared in the data. .loci julia > names ( ncats . loci ) output 9-element Array{Symbol,1}: :fca23 :fca37 :fca43 :fca45 :fca77 :fca78 :fca8 :fca90 :fca96 You'll likely immediately notice the colons, which might not be what you expected, and that the type is Array{Symbol,1} . This is because names pulls the column names from the .loci dataframe of a PopObj , which are actually Symbol and not String . You can just as easily convert them to a string by broadcasting String over names using a dot . . This conversion is only for the output and won't change anything in the PopObj (nor does it need changing!) conversion julia > String . ( names ( ncats . loci )) output 9-element Array{String,1}: \"fca23\" \"fca37\" \"fca43\" \"fca45\" \"fca77\" \"fca78\" \"fca8\" \"fca90\" \"fca96\" view genotypes This is the core of the PopObj type. Each colum is an array of tuples that have the genotypes of each individual in the order with which they appear in samples . The convenience here is that each column of the dataframe is named for the locus, therefore you access genotypes with PopObj.loci.locusname access fca8 julia > ncats . loci . fca8 output 237-element Array{Any,1}: (0, 0) (0, 0) (135, 143) (135, 133) (135, 133) (135, 143) (135, 135) (135, 143) (143, 137) (135, 135) (137, 141) (133, 129) (133, 129) (133, 133) (135, 131) (135, 129) (133, 129) (135, 129) (135, 135) (135, 131) \u22ee (139, 139) (137, 139) (137, 139) (143, 137) (135, 139) (143, 139) (135, 139) (135, 133) (135, 133) (133, 141) (133, 141) (133, 123) (133, 123) (133, 141) (133, 141) (133, 141) (143, 133) (135, 141) (143, 137) (135, 141) access fca23 julia > ncats . loci . fca23 output 237-element Array{Any,1}: (136, 146) (146, 146) (136, 146) (138, 138) (140, 146) (136, 146) (136, 146) (136, 146) (136, 146) (132, 132) (130, 136) (130, 136) (130, 130) (130, 136) (136, 136) (136, 146) (130, 144) (138, 138) (136, 144) (130, 136) \u22ee (136, 136) (136, 140) (136, 140) (136, 136) (136, 136) (136, 140) (136, 138) (136, 136) (136, 136) (130, 146) (138, 138) (138, 138) (136, 146) (130, 136) (136, 146) (130, 130) (136, 144) (130, 136) (130, 146) Slices general You can likewise use slices to access parts of these data. If you're migrating from R or Python, it's the simple bracket accessor you're already familiar with, used to pull out a range of values. Julia just calls them slices. Let's look at a slice of .name . slice .name julia > ncats . samples . name [ 1 : 6 ] output 6-element Array{String,1}: \"N215\" \"N216\" \"N217\" \"N218\" \"N219\" \"N220\" Here's another example: slice .loci julia > names ( ncats . loci )[ 3 : end ] output 7-element Array{Symbol,1}: :fca43 :fca45 :fca77 :fca78 :fca8 :fca90 :fca96 :end All things start at 1, so there is no need for a special word for it. On the other hand, objects can have unknown lengths or varied lengths as you work with them. In Julia, use the word end in a slice range to indicate you want it to go to the end,, regardless of length or known size. One more example withh genotypes: slice genotypes julia > ncats . loci . fca8 [ 1 : 3 ] output 3-element Array{Any,1}: (0, 0) (0, 0) (135, 143) Operating on accessors These accessors follow the exact same format as the dot operator in Python, or the $ operator in R, meaning these objects can be assigned to new variables, you can operate on them, iterate over them, etc. Here's a simple example to display the unique population ID's in your PopObj unique julia > unique ( ncats . samples . population ) output 17-element Array{Union{Int64, String},1}: \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" \"10\" \"11\" \"12\" \"13\" \"14\" \"15\" \"16\" \"17\" Pipes Julia has native piping (much like BASH) which uses the syntax |> (pipe + greater-than). With a pipe, unique(ncats.samples.population) can also be rewritten as ncats.samples.population |> unique for the same result. It's often a matter of preference for which you consider more readable. Use the Pipe package for even more robust piping where you can specify which argument the pipe relates to! \ud83d\uded1\u274c What to avoid! \u274c\ud83d\uded1 Given the relationships of the ordered list of individuals ( .name ) and the order of genotypes in .loci , NEVER USE sort , sort! , or manually arrange/add/delete anything in either dataframes loci or samples !!! There are included functions remove_loci! and remove_inds! that do that kind of thing. That being said, you can rename individuals and their popid's without issue. Just no manual moving or deleting!","title":"Accessing"},{"location":"PopObj_accessing/#loading-in-the-data","text":"Let's keep things simple by loading in the nancycats data and calling it ncats load nancycats julia > ncats = nancycats () ; summary ( ncats ) output Object of type PopObj: Longitude: Any[missing, missing, missing, missing, missing, missing] \u2026 Any[missing, missing, missing, missing, missing, missing] Latitude: Any[missing, missing, missing, missing, missing, missing] \u2026 Any[missing, missing, missing, missing, missing, missing] Number of individuals: 237 [\"N215\", \"N216\", \"N217\"] \u2026 [\"N281\", \"N289\", \"N290\"] Number of loci: 9 [\"fca23\", \"fca37\", \"fca43\"] \u2026 [\"fca8\", \"fca90\", \"fca96\"] Ploidy: Int8[2, 2, 2] \u2026 Int8[2, 2, 2] Number of populations: 17 #samp_id | Pop -------------- 10 | 1 22 | 2 12 | 3 23 | 4 15 | 5 11 | 6 14 | 7 10 | 8 9 | 9 11 | 10 20 | 11 14 | 12 13 | 13 17 | 14 11 | 15 12 | 16 13 | 17 Available .samples fields: .name, .population, .ploidy, .longitude, .latitude Note the last line of the output. These samples fields can be accessed by name using the dot . accessor. Now that we have nancycats loaded in, we can use standard Julia accessor conventions to view the elements within our PopObj.","title":"Loading in the data"},{"location":"PopObj_accessing/#samples","text":"","title":"samples"},{"location":"PopObj_accessing/#samples_1","text":"To view the entire samples dataframe .samples julia > ncats . samples output 237 \u00d75 DataFrames . DataFrame \u2502 Row \u2502 name \u2502 population \u2502 ploidy \u2502 longitude \u2502 latitude \u2502 \u2502 \u2502 String \u2502 Categorical\u2026\u2370 \u2502 Int8 \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 N215 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 2 \u2502 N216 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 3 \u2502 N217 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 4 \u2502 N218 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 5 \u2502 N219 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 6 \u2502 N220 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 7 \u2502 N221 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 8 \u2502 N222 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 9 \u2502 N223 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 10 \u2502 N224 \u2502 \"1\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 11 \u2502 N7 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 12 \u2502 N141 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 13 \u2502 N142 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 14 \u2502 N143 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 15 \u2502 N144 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 16 \u2502 N145 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 17 \u2502 N146 \u2502 \"2\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u22ee \u2502 220 \u2502 N258 \u2502 \"16\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 221 \u2502 N259 \u2502 \"16\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 222 \u2502 N260 \u2502 \"16\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 223 \u2502 N261 \u2502 \"16\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 224 \u2502 N262 \u2502 \"16\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 225 \u2502 N282 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 226 \u2502 N283 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 227 \u2502 N288 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 228 \u2502 N291 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 229 \u2502 N292 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 230 \u2502 N293 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 231 \u2502 N294 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 232 \u2502 N295 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 233 \u2502 N296 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 234 \u2502 N297 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 235 \u2502 N281 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 236 \u2502 N289 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502 \u2502 237 \u2502 N290 \u2502 \"17\" \u2502 2 \u2502 missing \u2502 missing \u2502","title":".samples"},{"location":"PopObj_accessing/#name","text":"This will access the names of the individuals as they appeared in the data. .ind julia > ncats . samples . name output 237-element Array{String,1}: \"N215\" \"N216\" \"N217\" \"N218\" \"N219\" \"N220\" \"N221\" \"N222\" \"N223\" \"N224\" \"N7\" \"N141\" \"N142\" \"N143\" \"N144\" \"N145\" \"N146\" \"N147\" \"N148\" \"N149\" \u22ee \"N256\" \"N257\" \"N258\" \"N259\" \"N260\" \"N261\" \"N262\" \"N282\" \"N283\" \"N288\" \"N291\" \"N292\" \"N293\" \"N294\" \"N295\" \"N296\" \"N297\" \"N281\" \"N289\" \"N290\"","title":".name"},{"location":"PopObj_accessing/#population","text":"This will access the names of the populations associated with each individual, in the same order as the individuals. .popid julia > ncats . population output 237-element Array{Union{Int64, String},1}: \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \"2\" \u22ee \"16\" \"16\" \"16\" \"16\" \"16\" \"16\" \"16\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" \"17\" These ID's aren't super informative. Later, we'll change them using the popid! command.","title":".population"},{"location":"PopObj_accessing/#ploidy","text":"This shows you the ploidy of the data per individual. .ploidy julia > ncats . samples . ploidy output 237-element Array{Int8,1}: 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 \u22ee 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2","title":".ploidy"},{"location":"PopObj_accessing/#latitude","text":"This accesses the latitude information of the PopObj. If there is none, like in the nancycats data, it returns an empty array. .latitude julia > ncats . samples . latitude output 237-element Array{Any,1}: missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing \u22ee missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing","title":".latitude"},{"location":"PopObj_accessing/#longitude","text":"This accesses the longitude information of the PopObj. Like before, iIf there is none, like in the nancycats data, it returns an empty array. .longitude julia > ncats . samples . longitude output 237-element Array{Any,1}: missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing \u22ee missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing missing Seeing some location info The nancycats data has some weird coordinate system for information, so those data were omitted. If you want a proof of concept for .longitude and .latitude , load in gulfsharks and try it out. We'll use hcat (horizontal concatination) to horizontally bind the individual names, their latitude, and longitude. Later, you'll see that the locations command does this and a bit more. load gulfsharks julia > sharks = gulfsharks () ; # semicolon just supresses printing output julia > hcat ( sharks . samples . name , sharks . samples . latitude , sharks . samples . longitude ) output 212\u00d73 Array{Any,2}: \"cc_001\" 28.3062 -80.5993 \"cc_002\" 28.3079 -80.5995 \"cc_003\" 28.3023 -80.5996 \"cc_005\" 28.6123 -80.4225 \"cc_007\" 27.8666 -80.3578 \"cc_008\" 27.8666 -80.3579 \"cc_009\" 27.8682 -80.3482 \"cc_010\" 27.8711 -80.3482 \"cc_012\" 28.4815 -80.4303 \"cc_013\" 28.2421 -80.2494 \"cc_014\" 28.2428 -80.2496 \"cc_015\" 28.2378 -80.2496 \"cc_016\" 28.2414 -80.2498 \"cc_017\" 28.236 -80.2495 \"cc_018\" 28.2364 -80.2494 \"cc_019\" 28.3906 -80.4963 \"cc_020\" 28.3902 -80.4968 \"cc_021\" 28.3861 -80.4967 \"cc_022\" 28.3869 -80.4966 \"cc_023\" 28.3865 -80.496 \u22ee \"seg_001\" 29.8901 -87.7189 \"seg_003\" 30.1943 -88.0007 \"seg_009\" 30.0021 -88.0493 \"seg_010\" 30.0069 -88.049 \"seg_011\" 29.8362 -88.1675 \"seg_012\" 29.5057 -88.0546 \"seg_014\" 30.1428 -88.2974 \"seg_015\" 30.2074 -88.36 \"seg_016\" 30.1151 -88.3922 \"seg_018\" 29.8362 -88.168 \"seg_021\" 29.9466 -86.0399 \"seg_023\" 29.9969 -85.6494 \"seg_024\" 29.6966 -87.4403 \"seg_025\" 30.064 -86.5374 \"seg_026\" 30.0696 -86.5376 \"seg_027\" 29.9065 -86.0905 \"seg_028\" 30.0532 -87.3661 \"seg_029\" 30.0522 -87.3662 \"seg_030\" 29.8234 -85.7143 \"seg_031\" 29.8234 -85.7143 \u200b```","title":".longitude"},{"location":"PopObj_accessing/#loci","text":"","title":"loci"},{"location":"PopObj_accessing/#loci_1","text":"This will show you the entire loci dataframe .loci julia > ncats . loci output 237\u00d79 DataFrames.DataFrame. Omitted printing of 2 columns \u2502 Row \u2502 fca23 \u2502 fca37 \u2502 fca43 \u2502 fca45 \u2502 fca77 \u2502 fca78 \u2502 fca8 \u2502 \u2502 \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 (136, 146) \u2502 (208, 208) \u2502 (139, 139) \u2502 (116, 120) \u2502 (156, 156) \u2502 (142, 148) \u2502 missing \u2502 \u2502 2 \u2502 (146, 146) \u2502 (208, 208) \u2502 (139, 145) \u2502 (120, 126) \u2502 (156, 156) \u2502 (142, 148) \u2502 missing \u2502 \u2502 3 \u2502 (136, 146) \u2502 (210, 210) \u2502 (141, 141) \u2502 (116, 116) \u2502 (152, 156) \u2502 (142, 142) \u2502 (135, 143) \u2502 \u2502 4 \u2502 (138, 138) \u2502 (208, 208) \u2502 (139, 141) \u2502 (116, 126) \u2502 (150, 150) \u2502 (142, 148) \u2502 (133, 135) \u2502 \u2502 5 \u2502 (140, 146) \u2502 (208, 208) \u2502 (141, 145) \u2502 (126, 126) \u2502 (152, 152) \u2502 (142, 148) \u2502 (133, 135) \u2502 \u2502 6 \u2502 (136, 146) \u2502 (208, 208) \u2502 (145, 149) \u2502 (120, 126) \u2502 (150, 156) \u2502 (148, 148) \u2502 (135, 143) \u2502 \u2502 7 \u2502 (136, 146) \u2502 (208, 208) \u2502 (139, 145) \u2502 (116, 126) \u2502 (152, 152) \u2502 (142, 148) \u2502 (135, 135) \u2502 \u2502 8 \u2502 (136, 146) \u2502 (208, 212) \u2502 (135, 149) \u2502 (120, 126) \u2502 (154, 158) \u2502 (142, 148) \u2502 (135, 143) \u2502 \u2502 9 \u2502 (136, 146) \u2502 (208, 212) \u2502 (139, 139) \u2502 (116, 126) \u2502 (150, 160) \u2502 (142, 142) \u2502 (137, 143) \u2502 \u2502 10 \u2502 (132, 132) \u2502 (208, 208) \u2502 (141, 145) \u2502 (120, 126) \u2502 (150, 156) \u2502 (148, 148) \u2502 (135, 135) \u2502 \u2502 11 \u2502 (130, 136) \u2502 (182, 182) \u2502 (137, 145) \u2502 (128, 128) \u2502 (152, 152) \u2502 (142, 150) \u2502 (137, 141) \u2502 \u2502 12 \u2502 (130, 136) \u2502 (182, 208) \u2502 (135, 145) \u2502 (126, 128) \u2502 (144, 150) \u2502 (140, 140) \u2502 (129, 133) \u2502 \u2502 13 \u2502 (130, 130) \u2502 (208, 208) \u2502 (135, 145) \u2502 (128, 130) \u2502 (152, 156) \u2502 (142, 142) \u2502 (129, 133) \u2502 \u2502 14 \u2502 (130, 136) \u2502 (182, 206) \u2502 (135, 135) \u2502 (128, 130) \u2502 (156, 156) \u2502 (142, 142) \u2502 (133, 133) \u2502 \u2502 15 \u2502 (136, 136) \u2502 (208, 208) \u2502 (137, 137) \u2502 (126, 130) \u2502 (152, 152) \u2502 (140, 142) \u2502 (131, 135) \u2502 \u2502 16 \u2502 (136, 146) \u2502 (182, 192) \u2502 (135, 135) \u2502 (128, 130) \u2502 (144, 144) \u2502 (142, 142) \u2502 (129, 135) \u2502 \u2502 17 \u2502 (130, 144) \u2502 (182, 192) \u2502 (133, 133) \u2502 (126, 126) \u2502 (144, 144) \u2502 (140, 140) \u2502 (129, 133) \u2502 \u22ee \u2502 220 \u2502 (136, 140) \u2502 (208, 208) \u2502 (139, 145) \u2502 (122, 126) \u2502 (144, 152) \u2502 (142, 150) \u2502 (137, 139) \u2502 \u2502 221 \u2502 (136, 140) \u2502 (206, 208) \u2502 (145, 149) \u2502 (126, 126) \u2502 (152, 152) \u2502 (142, 142) \u2502 (137, 143) \u2502 \u2502 222 \u2502 (136, 136) \u2502 (210, 210) \u2502 (145, 149) \u2502 (122, 126) \u2502 (152, 152) \u2502 (150, 150) \u2502 (135, 139) \u2502 \u2502 223 \u2502 (136, 136) \u2502 (208, 208) \u2502 (145, 145) \u2502 (122, 126) \u2502 (152, 156) \u2502 (142, 142) \u2502 (139, 143) \u2502 \u2502 224 \u2502 (136, 140) \u2502 (208, 208) \u2502 (149, 149) \u2502 (120, 126) \u2502 (152, 152) \u2502 (142, 150) \u2502 (135, 139) \u2502 \u2502 225 \u2502 (136, 138) \u2502 (208, 208) \u2502 (135, 139) \u2502 missing \u2502 (150, 156) \u2502 (142, 150) \u2502 (133, 135) \u2502 \u2502 226 \u2502 (136, 136) \u2502 (182, 182) \u2502 (135, 139) \u2502 missing \u2502 (146, 156) \u2502 (142, 142) \u2502 (133, 135) \u2502 \u2502 227 \u2502 (136, 136) \u2502 (182, 208) \u2502 (135, 139) \u2502 missing \u2502 (150, 156) \u2502 (142, 150) \u2502 (133, 141) \u2502 \u2502 228 \u2502 (130, 146) \u2502 (208, 208) \u2502 (141, 141) \u2502 missing \u2502 (148, 156) \u2502 (142, 150) \u2502 (133, 141) \u2502 \u2502 229 \u2502 (138, 138) \u2502 (208, 208) \u2502 (141, 145) \u2502 missing \u2502 (148, 156) \u2502 (142, 142) \u2502 (123, 133) \u2502 \u2502 230 \u2502 (138, 138) \u2502 (208, 208) \u2502 (139, 139) \u2502 missing \u2502 (150, 156) \u2502 (142, 142) \u2502 (123, 133) \u2502 \u2502 231 \u2502 (136, 146) \u2502 (208, 208) \u2502 (139, 139) \u2502 missing \u2502 (150, 150) \u2502 (142, 148) \u2502 (133, 141) \u2502 \u2502 232 \u2502 (130, 136) \u2502 (208, 208) \u2502 (139, 145) \u2502 missing \u2502 (152, 158) \u2502 (142, 142) \u2502 (133, 141) \u2502 \u2502 233 \u2502 (136, 146) \u2502 (208, 220) \u2502 (139, 145) \u2502 missing \u2502 (150, 158) \u2502 (142, 148) \u2502 (133, 141) \u2502 \u2502 234 \u2502 (130, 130) \u2502 (208, 208) \u2502 (135, 145) \u2502 missing \u2502 (148, 156) \u2502 (142, 142) \u2502 (133, 143) \u2502 \u2502 235 \u2502 (136, 144) \u2502 (208, 208) \u2502 (143, 143) \u2502 missing \u2502 (144, 150) \u2502 (142, 150) \u2502 (135, 141) \u2502 \u2502 236 \u2502 (130, 136) \u2502 (208, 208) \u2502 (135, 145) \u2502 missing \u2502 (150, 150) \u2502 (142, 142) \u2502 (137, 143) \u2502 \u2502 237 \u2502 (130, 146) \u2502 (208, 208) \u2502 (135, 139) \u2502 missing \u2502 (150, 156) \u2502 (142, 150) \u2502 (135, 141) \u2502","title":".loci"},{"location":"PopObj_accessing/#locus-names","text":"This will access the names of the loci as they appeared in the data. .loci julia > names ( ncats . loci ) output 9-element Array{Symbol,1}: :fca23 :fca37 :fca43 :fca45 :fca77 :fca78 :fca8 :fca90 :fca96 You'll likely immediately notice the colons, which might not be what you expected, and that the type is Array{Symbol,1} . This is because names pulls the column names from the .loci dataframe of a PopObj , which are actually Symbol and not String . You can just as easily convert them to a string by broadcasting String over names using a dot . . This conversion is only for the output and won't change anything in the PopObj (nor does it need changing!) conversion julia > String . ( names ( ncats . loci )) output 9-element Array{String,1}: \"fca23\" \"fca37\" \"fca43\" \"fca45\" \"fca77\" \"fca78\" \"fca8\" \"fca90\" \"fca96\"","title":"locus names"},{"location":"PopObj_accessing/#view-genotypes","text":"This is the core of the PopObj type. Each colum is an array of tuples that have the genotypes of each individual in the order with which they appear in samples . The convenience here is that each column of the dataframe is named for the locus, therefore you access genotypes with PopObj.loci.locusname access fca8 julia > ncats . loci . fca8 output 237-element Array{Any,1}: (0, 0) (0, 0) (135, 143) (135, 133) (135, 133) (135, 143) (135, 135) (135, 143) (143, 137) (135, 135) (137, 141) (133, 129) (133, 129) (133, 133) (135, 131) (135, 129) (133, 129) (135, 129) (135, 135) (135, 131) \u22ee (139, 139) (137, 139) (137, 139) (143, 137) (135, 139) (143, 139) (135, 139) (135, 133) (135, 133) (133, 141) (133, 141) (133, 123) (133, 123) (133, 141) (133, 141) (133, 141) (143, 133) (135, 141) (143, 137) (135, 141) access fca23 julia > ncats . loci . fca23 output 237-element Array{Any,1}: (136, 146) (146, 146) (136, 146) (138, 138) (140, 146) (136, 146) (136, 146) (136, 146) (136, 146) (132, 132) (130, 136) (130, 136) (130, 130) (130, 136) (136, 136) (136, 146) (130, 144) (138, 138) (136, 144) (130, 136) \u22ee (136, 136) (136, 140) (136, 140) (136, 136) (136, 136) (136, 140) (136, 138) (136, 136) (136, 136) (130, 146) (138, 138) (138, 138) (136, 146) (130, 136) (136, 146) (130, 130) (136, 144) (130, 136) (130, 146)","title":"view genotypes"},{"location":"PopObj_accessing/#slices","text":"","title":"Slices"},{"location":"PopObj_accessing/#general","text":"You can likewise use slices to access parts of these data. If you're migrating from R or Python, it's the simple bracket accessor you're already familiar with, used to pull out a range of values. Julia just calls them slices. Let's look at a slice of .name . slice .name julia > ncats . samples . name [ 1 : 6 ] output 6-element Array{String,1}: \"N215\" \"N216\" \"N217\" \"N218\" \"N219\" \"N220\" Here's another example: slice .loci julia > names ( ncats . loci )[ 3 : end ] output 7-element Array{Symbol,1}: :fca43 :fca45 :fca77 :fca78 :fca8 :fca90 :fca96 :end All things start at 1, so there is no need for a special word for it. On the other hand, objects can have unknown lengths or varied lengths as you work with them. In Julia, use the word end in a slice range to indicate you want it to go to the end,, regardless of length or known size. One more example withh genotypes: slice genotypes julia > ncats . loci . fca8 [ 1 : 3 ] output 3-element Array{Any,1}: (0, 0) (0, 0) (135, 143)","title":"general"},{"location":"PopObj_accessing/#operating-on-accessors","text":"These accessors follow the exact same format as the dot operator in Python, or the $ operator in R, meaning these objects can be assigned to new variables, you can operate on them, iterate over them, etc. Here's a simple example to display the unique population ID's in your PopObj unique julia > unique ( ncats . samples . population ) output 17-element Array{Union{Int64, String},1}: \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" \"10\" \"11\" \"12\" \"13\" \"14\" \"15\" \"16\" \"17\" Pipes Julia has native piping (much like BASH) which uses the syntax |> (pipe + greater-than). With a pipe, unique(ncats.samples.population) can also be rewritten as ncats.samples.population |> unique for the same result. It's often a matter of preference for which you consider more readable. Use the Pipe package for even more robust piping where you can specify which argument the pipe relates to!","title":"Operating on accessors"},{"location":"PopObj_accessing/#what-to-avoid","text":"Given the relationships of the ordered list of individuals ( .name ) and the order of genotypes in .loci , NEVER USE sort , sort! , or manually arrange/add/delete anything in either dataframes loci or samples !!! There are included functions remove_loci! and remove_inds! that do that kind of thing. That being said, you can rename individuals and their popid's without issue. Just no manual moving or deleting!","title":"\ud83d\uded1\u274c What to avoid! \u274c\ud83d\uded1"},{"location":"commands/","text":"These are the included PopObj viewing and manipulating commands. Using standard Julia conventions, only commands ending with a bang ! are mutable, meaning they alter the input data. So, commands like popid will show you population ID's, whereas popid! will change them in your PopObj . The mutable commands here alter the data in your PopObj , but not the source data (i.e. the files used to create the PopObj ). To follow along like a tutorial, use the gulfsharks data. Load the data in if you haven't already: julia > using PopGen julia > sharks = gulfsharks () ; individuals view individuals' names sample_names ( x :: PopObj ) View individual/sample names in a PopObj . This is equivalent to PopObj.samples.name indnames sample_names ( sharks ) output 212-element Array{String,1}: \"cc_001\" \"cc_002\" \"cc_003\" \"cc_005\" \"cc_007\" \"cc_008\" \"cc_009\" \"cc_010\" \"cc_012\" \"cc_013\" \u22ee \"seg_023\" \"seg_024\" \"seg_025\" \"seg_026\" \"seg_027\" \"seg_028\" \"seg_029\" \"seg_030\" \"seg_031\" remove individuals remove_samples! ( x :: PopObj , samp_id :: Union { String , Array { String , 1 }}) Removes selected individuals from a PopObj . Input can be a single sample, or an array of samples. Will output entire PopObj , so it's better to use a semicolon to suppress the output. Use summary or .name if you want to confirm that the samples were removed. This command will inform you if samples were not found in the data. Examples: single individual julia > remove_samples! ( sharks , \"cc_001\" ) ; julia > summary ( sharks ) single output Object of type PopObj: Longitude: [\"-80.59958\", \"-80.42248\", \"-80.35779\"] \u2026 [\"-87.36617\", \"-85.71432\", \"-85.71432\"] Latitude: [\"28.30624\", \"28.30787\", \"28.30234\"] \u2026 [\"30.05217\", \"29.82344\", \"29.82344\"] Number of individuals: 211 [\"cc_002\", \"cc_003\", \"cc_005\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"contig_35208\", \"contig_23109\", \"contig_4493\"] \u2026 [\"contig_19384\", \"contig_22368\", \"contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 20 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available .samples fields: .name, .population, .ploidy, .longitude, .latitude multiple individuals julia > remove_samples! ( sharks , [ \"cc_001\" , \"cc_002\" , \"cc_003\" ]) ; julia > summary ( sharks ) multiple output NOTICE: ind \"cc_001\" not found! Object of type PopObj: Longitude: [\"-80.34815\", \"-80.34822\", \"-80.43027\"] \u2026 [\"-87.36617\", \"-85.71432\", \"-85.71432\"] Latitude: [\"28.30624\", \"28.30787\", \"28.30234\"] \u2026 [\"30.05217\", \"29.82344\", \"29.82344\"] Number of individuals: 209 [\"cc_005\", \"cc_007\", \"cc_008\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"contig_35208\", \"contig_23109\", \"contig_4493\"] \u2026 [\"contig_19384\", \"contig_22368\", \"contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 18 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available .samples fields: .name, .population, .ploidy, .longitude, .latitude sample not found! If removing a single sample and it is not found in the PopObj, an error will be returned. However, if removing multiple samples, you will receive a notice above the PopObj summary indicating which individuals were not found, while removing the ones that were. population ID's view population names populations ( x :: PopObj ; listall :: Bool = false ) Just as you can view population ID's with .population , you can also view them with the populations command, which by default shows you a summary of the number of individuals in each population, much like you see when using summary . popid julia > populations ( sharks ) output \u2502 Row \u2502 population \u2502 count \u2502 \u2502 \u2502 Categorical\u2026\u2370 \u2502 Int32 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 1 \u2502 21 \u2502 \u2502 2 \u2502 2 \u2502 30 \u2502 \u2502 3 \u2502 3 \u2502 28 \u2502 \u2502 4 \u2502 4 \u2502 65 \u2502 \u2502 5 \u2502 5 \u2502 28 \u2502 \u2502 6 \u2502 6 \u2502 20 \u2502 \u2502 7 \u2502 7 \u2502 20 \u2502 You can use the keyword listall=true to display each individual and their associated population as a DataFrame. You'll notice the DataFrame looks remarkably like the first two columns of the one from locations , and it sort of is. Unlike locations , this will not give you an error when location data is missing. listall=true julia > populations ( sharks , listall = true ) output 212\u00d72 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 \u2502 \u2502 String \u2502 Union\u2026 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 synonymous functions You can use the command population for the same functionality. We made the commands population and populations synonymous so you wouldn't have to memorize if the name was singular or plural-- it just works! This also applies to populations! and population! rename populations popid! ( x :: PopObj ; rename :: Dict ) Rename the population ID's of a PopObj (the .popid ). Uses a Dict of [popid] => replacement to rename. It returns popid(::PopObj,listall=true) of your renamed PopObj. rename populations # create a dictionary of name conversions julia > new_popnames = Dict ( 1 => \"Cape Canaveral\" , 2 => \"Georgia\" , 3 => \"S Carolina\" , 4 => \"FL Keys\" , 5 => \"Mideast Gulf\" , 6 => \"Northeast Gulf\" , 7 => \"Southeast Gulf\" ) julia > popid! ( sharks , rename = new_popnames ) output 212\u00d72 DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 \u2502 \u2502 String \u2502 Union\u2026 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 Cape Canaveral \u2502 \u2502 2 \u2502 cc_002 \u2502 Cape Canaveral \u2502 \u2502 3 \u2502 cc_003 \u2502 Cape Canaveral \u2502 \u2502 4 \u2502 cc_005 \u2502 Cape Canaveral \u2502 \u2502 5 \u2502 cc_007 \u2502 Cape Canaveral \u2502 \u2502 6 \u2502 cc_008 \u2502 Cape Canaveral \u2502 \u2502 7 \u2502 cc_009 \u2502 Cape Canaveral \u2502 \u2502 8 \u2502 cc_010 \u2502 Cape Canaveral \u2502 \u2502 9 \u2502 cc_012 \u2502 Cape Canaveral \u2502 \u2502 10 \u2502 cc_013 \u2502 Cape Canaveral \u2502 \u2502 11 \u2502 cc_014 \u2502 Cape Canaveral \u2502 \u2502 12 \u2502 cc_015 \u2502 Cape Canaveral \u2502 \u2502 13 \u2502 cc_016 \u2502 Cape Canaveral \u2502 \u2502 14 \u2502 cc_017 \u2502 Cape Canaveral \u2502 \u2502 15 \u2502 cc_018 \u2502 Cape Canaveral \u2502 \u2502 16 \u2502 cc_019 \u2502 Cape Canaveral \u2502 \u2502 17 \u2502 cc_020 \u2502 Cape Canaveral \u2502 \u2502 18 \u2502 cc_021 \u2502 Cape Canaveral \u2502 \u22ee \u2502 194 \u2502 seg_003 \u2502 Southeast Gulf \u2502 \u2502 195 \u2502 seg_009 \u2502 Southeast Gulf \u2502 \u2502 196 \u2502 seg_010 \u2502 Southeast Gulf \u2502 \u2502 197 \u2502 seg_011 \u2502 Southeast Gulf \u2502 \u2502 198 \u2502 seg_012 \u2502 Southeast Gulf \u2502 \u2502 199 \u2502 seg_014 \u2502 Southeast Gulf \u2502 \u2502 200 \u2502 seg_015 \u2502 Southeast Gulf \u2502 \u2502 201 \u2502 seg_016 \u2502 Southeast Gulf \u2502 \u2502 202 \u2502 seg_018 \u2502 Southeast Gulf \u2502 \u2502 203 \u2502 seg_021 \u2502 Southeast Gulf \u2502 \u2502 204 \u2502 seg_023 \u2502 Southeast Gulf \u2502 \u2502 205 \u2502 seg_024 \u2502 Southeast Gulf \u2502 \u2502 206 \u2502 seg_025 \u2502 Southeast Gulf \u2502 \u2502 207 \u2502 seg_026 \u2502 Southeast Gulf \u2502 \u2502 208 \u2502 seg_027 \u2502 Southeast Gulf \u2502 \u2502 209 \u2502 seg_028 \u2502 Southeast Gulf \u2502 \u2502 210 \u2502 seg_029 \u2502 Southeast Gulf \u2502 \u2502 211 \u2502 seg_030 \u2502 Southeast Gulf \u2502 \u2502 212 \u2502 seg_031 \u2502 Southeast Gulf \u2502 display specific loci and/or samples view loci isolate_genotypes ( x :: PopObj ; samples = nothing , loci = nothing ) Default shows all genotypes for all individuals. Returns a DataFrame. all loci julia > isolate_genotypes ( sharks ) output 212\u00d72215 DataFrames.DataFrame. Omitted printing of 2209 columns \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 contig_10013 \u2502 contig_10028 \u2502 contig_10035 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026 \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (1, 1) \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 1) \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 (1, 2) \u2502 (2, 1) \u2502 (1, 1) \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 (1, 1) \u2502 (1, 2) \u2502 (2, 1) \u2502 (2, 1) \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 2) \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 Add the argument loci= specify a single locus (string) or multiple loci (array of strings) to display single locus julia > isolate_genotypes ( sharks , loci = \"contig_10001\" ) single output 212\u00d73 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026 \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 (1, 1) \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 (1, 1) \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 (1, 1) \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 (1, 1) \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 (1, 1) \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 (1, 1) \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 (1, 1) \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 (1, 1) \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 (1, 1) \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 (1, 1) \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 (1, 1) \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 (1, 1) \u2502 multiple loci julia > isolate_genotypes ( sharks , loci = [ \"contig_10001\" , \"contig_10028\" ]) multiple output 212\u00d74 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 contig_10028 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026 \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 view samples Add the argument samples= specify a single sample (string) or multiple samples (array of strings) to display single sample julia > isolate_genotypes ( sharks , samples = \"cc_001\" ) single output 1\u00d72215 DataFrames.DataFrame. Omitted printing of 2209 columns \u2502 Row \u2502 name \u2502 population \u2502 contig_10001 \u2502 contig_10013 \u2502 contig_10028 \u2502 contig_10035 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026\u2370 \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 multiple samples 2 \u00d72215 DataFrames . DataFrame . Omitted printing of 2209 columns \u2502 Row \u2502 name \u2502 population \u2502 contig_10001 \u2502 contig_10013 \u2502 contig_10028 \u2502 contig_10035 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026\u2370 \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 ( 1 , 1 ) \u2502 ( 1 , 1 ) \u2502 ( 1 , 1 ) \u2502 ( 1 , 1 ) \u2502 \u2502 2 \u2502 seg_028 \u2502 7 \u2502 ( 1 , 1 ) \u2502 ( 1 , 1 ) \u2502 ( 1 , 2 ) \u2502 ( 2 , 2 ) \u2502 It also means that you can combine the keywords samples= and loci= to further specify your output: both keywords isolate_genotypes ( sharks , samples = [ \"cc_001\" , \"seg_028\" ], loci = \"contig_10013\" ) output 2\u00d73 DataFrames.DataFrame \u2502 Row \u2502 name \u2502 population \u2502 contig_10013 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026\u2370 \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 \u2502 2 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 remove loci remove_loci! ( x :: PopObj , loci :: Union { String , Array { String , 1 }}) Removes selected loci from a PopObj . Input can be a single locus, or an array of loci. Examples: single locus julia > remove_loci! ( sharks , \"contig_35208\" ) ; julia > summary ( sharks ) single output Object of type PopObj: Longitude: [\"-80.59928\", \"-80.59954\", \"-80.59958\"] \u2026 [\"-87.36617\", \"-85.71432\", \"-85.71432\"] Latitude: [\"28.30624\", \"28.30787\", \"28.30234\"] \u2026 [\"30.05217\", \"29.82344\", \"29.82344\"] Number of individuals: 212 [\"cc_001\", \"cc_002\", \"cc_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2212 [\"contig_23109\", \"contig_4493\", \"contig_10742\"] \u2026 [\"contig_19384\", \"contig_22368\", \"contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available .samples fields: .name, .population, .ploidy, .longitude, .latitude multiple loci julia > remove_loci! ( sharks , [ \"contig_35208\" , \"contig_23109\" , \"contig_4493\" ]) ; julia > summary ( sharks ) multiple output NOTICE: locus \"contig_35208\" not found Object of type PopObj: Longitude: [\"-80.59928\", \"-80.59954\", \"-80.59958\"] \u2026 [\"-87.36617\", \"-85.71432\", \"-85.71432\"] Latitude: [\"28.30624\", \"28.30787\", \"28.30234\"] \u2026 [\"30.05217\", \"29.82344\", \"29.82344\"] Number of individuals: 212 [\"cc_001\", \"cc_002\", \"cc_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2210 [\"contig_10742\", \"contig_14898\", \"contig_8483\"] \u2026 [\"contig_19384\", \"contig_22368\", \"contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available .samples fields: .name, .population, .ploidy, .longitude, .latitude locus not found! If removing a single locus and it is not found in the PopObj, an error will be returned. However, if removing multiple loci, you will receive a notice above the PopObj summary indicating which loci were not found, while removing the ones that were. missing data view missing data missing ( x :: PopObj ) Used to show missingness information-- that is, loci missing allele information. This command outputs two DataFrames, the first being a count of number of missing loci per samples, the other being the number of times a locus is missing across samples. missing julia > missing ( sharks ) output by_ind = (212\u00d74 DataFrames.DataFrame. Omitted printing of 1 columns \u2502 Row \u2502 name \u2502 population \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 124 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 94 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 100 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 0 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 2 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 1 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 2 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 0 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 0 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 0 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 2 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 25 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 0 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 1 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 1 \u2502, by_loci = 2213\u00d72 DataFrames.DataFrame \u2502 Row \u2502 locus \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0 \u2502 \u2502 2 \u2502 contig_23109 \u2502 6 \u2502 \u2502 3 \u2502 contig_4493 \u2502 3 \u2502 \u2502 4 \u2502 contig_10742 \u2502 2 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0 \u2502 \u2502 7 \u2502 contig_8065 \u2502 0 \u2502 \u22ee \u2502 2206 \u2502 contig_24711 \u2502 0 \u2502 \u2502 2207 \u2502 contig_18959 \u2502 0 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 6 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 2 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 5 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 3 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 7 \u2502) missing outputs a named tuple of dataframes, which means there are two options for assignment: single assignment The first DataFrame of the named tuple is named by_sample and the second named by_loci . If you assign a single variable to this tuple, it will inherit those names as accessors like so: single assignment julia > miss = missing ( sharks ) ; by_ind julia> miss.by_sample 212\u00d74 DataFrame. Omitted printing of 1 columns \u2502 Row \u2502 name \u2502 population \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 String \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 124 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 94 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 100 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 0 \u2502 \u22ee \u2502 208 \u2502 seg_027 \u2502 7 \u2502 2 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 25 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 0 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 1 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 1 \u2502 by_loci julia> miss.by_loci 2213\u00d72 DataFrame \u2502 Row \u2502 locus \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0 \u2502 \u2502 2 \u2502 contig_23109 \u2502 6 \u2502 \u2502 3 \u2502 contig_4493 \u2502 3 \u2502 \u2502 4 \u2502 contig_10742 \u2502 2 \u2502 \u22ee \u2502 2209 \u2502 contig_27356 \u2502 2 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 5 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 3 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 7 \u2502 multiple assignment Python has this feature, however, if you're migrating from R, multiple assignment probably looks weird, or like flat-out sorcery. Whenever a function returns a tuple of values, like missing does, you can assign as many variables to it at once. missing julia > df1 , df2 = missing ( sharks ) ; df1 julia> df1 212\u00d74 DataFrames.DataFrame. Omitted printing of 1 columns \u2502 Row \u2502 name \u2502 population \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 124 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 94 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 100 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 0 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 2 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 1 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 2 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 0 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 0 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 0 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 2 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 25 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 0 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 1 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 1 \u2502 df2 julia> df2 2213\u00d72 DataFrames.DataFrame \u2502 Row \u2502 locus \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0 \u2502 \u2502 2 \u2502 contig_23109 \u2502 6 \u2502 \u2502 3 \u2502 contig_4493 \u2502 3 \u2502 \u2502 4 \u2502 contig_10742 \u2502 2 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0 \u2502 \u2502 7 \u2502 contig_8065 \u2502 0 \u2502 \u22ee \u2502 2206 \u2502 contig_24711 \u2502 0 \u2502 \u2502 2207 \u2502 contig_18959 \u2502 0 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 6 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 2 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 5 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 3 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 7 \u2502 a simple example If this still looks weird to you, here is a simple example to help wrap your mind around it. a , b , c , d = ( 1 , 2 , 3 ,[ 4 , 5 , 6 , 7 ]) where a = 1 b = 2 c = 3 d = [4, 5, 6, 7] embrace the convenience! plot missing data plot_missing ( x :: PopObj ; color = false ) Return an interactive plot of the number of missing loci in individuals of a PopObj , along with the number of missing individuals per locus. Use color = [color1, color2, ...] to set a custom color palette for the boxplots. Example: julia > plot_missing ( sharks ) saving interactive plots To save the interactive plots, you can use the savehtml function from the PlotlyJS.jl package: PlotlyJS . savehtml ( plot , \"filename.html\" ) If you don't specify a full path in the filename, it will save it in your current working directory. #example julia > using PlotlyJS ; julia > PlotlyJS . savehtml ( plot_missing ( sharks ), \"/home/pdimens/missingness.html\" ) use a third argument :embed to make the plots fully viewable offline. The output files are much larger (relatively) because it embeds the Plotly javeascript into the file. For context, the gulfsharks plot file is ~3.5mb when using :embed location data view location data locations ( x :: PopObj ) View location data ( .longitude and .latitude ) in a PopObj If you want to do your own plotting, or just to look at the spatial data of your PopObj, this function is handy. It takes no additional arguments and outputs a DataFrame of individual names, population ID's, and their latitude/longitude information. locations julia > locations ( sharks ) output 212\u00d74 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 longitude \u2502 latitude \u2502 \u2502 \u2502 String \u2502 Union\u2026 \u2502 Union\u2026 \u2502 Union\u2026 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 -80.5993 \u2502 28.3062 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 -80.5995 \u2502 28.3079 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 -80.5996 \u2502 28.3023 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 -80.4225 \u2502 28.6123 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 -80.3578 \u2502 27.8666 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 -80.3579 \u2502 27.8666 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 -80.3482 \u2502 27.8682 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 -87.4403 \u2502 29.6966 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 -86.5374 \u2502 30.064 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 -86.5376 \u2502 30.0696 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 -86.0905 \u2502 29.9065 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 -87.3661 \u2502 30.0532 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 -87.3662 \u2502 30.0522 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 -85.7143 \u2502 29.8234 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 -85.7143 \u2502 29.8234 \u2502 locations secondary feature There is a built-in component in locations to test if the location data 1) exists, and 2) is of equal length, or it will spit out an error. It's probably a good idea to do this for your data at least once to be assured everything is ok! add location data Location data can be added by directly accessing the fields .longitude and .latitude in your PopObj , such as this example: julia > sharks . samples . longitude = rand ( 1 : 50 , 212 ) ; # creates 212 unique random numbers between 1 and 50 julia > sharks . samples . latitdue = rand ( 20 : 30 , 212 ) ; # creates 212 unique random numbers between 20 and 30 However, if your data is in decimal minutes rather than decimal degrees, use the locations! function to add it to the fields. This function will do a conversion from decimal minutes to decimal degrees for you. To import those data into Julia, you'll likely want to use the wonderful CSV.jl package first. decimal minutes data locations! ( x :: PopObj ; xloc :: Array , yloc :: Array ) Adds location data (longitude, latitude) to PopObj . Takes decimal degrees or decimal minutes format. Must use minus-sign instead of cardinal directions (i.e. 14 32.11W is not vaild). Location data must be in order of individuals ( ind ). Replaces existing PopObj location data. Decimal Degrees : -11.431 Decimal Minutes : \"-11 43.11\" (must use space and double-quotes) If conversion is not necessary, can directly assign PopObj.longitude and PopObj.latitude as shown above. If you still wanted to use locations! but don't need a conversion, it still works: julia > long = a . longitude = rand ( 1 : 50 , 212 ) ; julia > lat = a . latitdue = rand ( 20 : 30 , 212 ) ; julia > locations! ( a , long , lat ) ; plot location data plot_locations ( x :: PopObj , region = \"world\" , projection = \"orthogonal\" ) You're encouraged to plot locations how you see fit. For convenience and speed, we provide this command to make a decent, albeit simple interactive plot (Plotly) and save some time. There is a sizeable list of available map projections and regions if you look this function up in the help?> REPL prompt. julia > plot_locations ( sharks )","title":"View/edit PopObj"},{"location":"commands/#individuals","text":"","title":"individuals"},{"location":"commands/#view-individuals-names","text":"sample_names ( x :: PopObj ) View individual/sample names in a PopObj . This is equivalent to PopObj.samples.name indnames sample_names ( sharks ) output 212-element Array{String,1}: \"cc_001\" \"cc_002\" \"cc_003\" \"cc_005\" \"cc_007\" \"cc_008\" \"cc_009\" \"cc_010\" \"cc_012\" \"cc_013\" \u22ee \"seg_023\" \"seg_024\" \"seg_025\" \"seg_026\" \"seg_027\" \"seg_028\" \"seg_029\" \"seg_030\" \"seg_031\"","title":"view individuals' names"},{"location":"commands/#remove-individuals","text":"remove_samples! ( x :: PopObj , samp_id :: Union { String , Array { String , 1 }}) Removes selected individuals from a PopObj . Input can be a single sample, or an array of samples. Will output entire PopObj , so it's better to use a semicolon to suppress the output. Use summary or .name if you want to confirm that the samples were removed. This command will inform you if samples were not found in the data. Examples: single individual julia > remove_samples! ( sharks , \"cc_001\" ) ; julia > summary ( sharks ) single output Object of type PopObj: Longitude: [\"-80.59958\", \"-80.42248\", \"-80.35779\"] \u2026 [\"-87.36617\", \"-85.71432\", \"-85.71432\"] Latitude: [\"28.30624\", \"28.30787\", \"28.30234\"] \u2026 [\"30.05217\", \"29.82344\", \"29.82344\"] Number of individuals: 211 [\"cc_002\", \"cc_003\", \"cc_005\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"contig_35208\", \"contig_23109\", \"contig_4493\"] \u2026 [\"contig_19384\", \"contig_22368\", \"contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 20 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available .samples fields: .name, .population, .ploidy, .longitude, .latitude multiple individuals julia > remove_samples! ( sharks , [ \"cc_001\" , \"cc_002\" , \"cc_003\" ]) ; julia > summary ( sharks ) multiple output NOTICE: ind \"cc_001\" not found! Object of type PopObj: Longitude: [\"-80.34815\", \"-80.34822\", \"-80.43027\"] \u2026 [\"-87.36617\", \"-85.71432\", \"-85.71432\"] Latitude: [\"28.30624\", \"28.30787\", \"28.30234\"] \u2026 [\"30.05217\", \"29.82344\", \"29.82344\"] Number of individuals: 209 [\"cc_005\", \"cc_007\", \"cc_008\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"contig_35208\", \"contig_23109\", \"contig_4493\"] \u2026 [\"contig_19384\", \"contig_22368\", \"contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 18 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available .samples fields: .name, .population, .ploidy, .longitude, .latitude sample not found! If removing a single sample and it is not found in the PopObj, an error will be returned. However, if removing multiple samples, you will receive a notice above the PopObj summary indicating which individuals were not found, while removing the ones that were.","title":"remove individuals"},{"location":"commands/#population-ids","text":"","title":"population ID's"},{"location":"commands/#view-population-names","text":"populations ( x :: PopObj ; listall :: Bool = false ) Just as you can view population ID's with .population , you can also view them with the populations command, which by default shows you a summary of the number of individuals in each population, much like you see when using summary . popid julia > populations ( sharks ) output \u2502 Row \u2502 population \u2502 count \u2502 \u2502 \u2502 Categorical\u2026\u2370 \u2502 Int32 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 1 \u2502 21 \u2502 \u2502 2 \u2502 2 \u2502 30 \u2502 \u2502 3 \u2502 3 \u2502 28 \u2502 \u2502 4 \u2502 4 \u2502 65 \u2502 \u2502 5 \u2502 5 \u2502 28 \u2502 \u2502 6 \u2502 6 \u2502 20 \u2502 \u2502 7 \u2502 7 \u2502 20 \u2502 You can use the keyword listall=true to display each individual and their associated population as a DataFrame. You'll notice the DataFrame looks remarkably like the first two columns of the one from locations , and it sort of is. Unlike locations , this will not give you an error when location data is missing. listall=true julia > populations ( sharks , listall = true ) output 212\u00d72 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 \u2502 \u2502 String \u2502 Union\u2026 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 synonymous functions You can use the command population for the same functionality. We made the commands population and populations synonymous so you wouldn't have to memorize if the name was singular or plural-- it just works! This also applies to populations! and population!","title":"view population names"},{"location":"commands/#rename-populations","text":"popid! ( x :: PopObj ; rename :: Dict ) Rename the population ID's of a PopObj (the .popid ). Uses a Dict of [popid] => replacement to rename. It returns popid(::PopObj,listall=true) of your renamed PopObj. rename populations # create a dictionary of name conversions julia > new_popnames = Dict ( 1 => \"Cape Canaveral\" , 2 => \"Georgia\" , 3 => \"S Carolina\" , 4 => \"FL Keys\" , 5 => \"Mideast Gulf\" , 6 => \"Northeast Gulf\" , 7 => \"Southeast Gulf\" ) julia > popid! ( sharks , rename = new_popnames ) output 212\u00d72 DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 \u2502 \u2502 String \u2502 Union\u2026 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 Cape Canaveral \u2502 \u2502 2 \u2502 cc_002 \u2502 Cape Canaveral \u2502 \u2502 3 \u2502 cc_003 \u2502 Cape Canaveral \u2502 \u2502 4 \u2502 cc_005 \u2502 Cape Canaveral \u2502 \u2502 5 \u2502 cc_007 \u2502 Cape Canaveral \u2502 \u2502 6 \u2502 cc_008 \u2502 Cape Canaveral \u2502 \u2502 7 \u2502 cc_009 \u2502 Cape Canaveral \u2502 \u2502 8 \u2502 cc_010 \u2502 Cape Canaveral \u2502 \u2502 9 \u2502 cc_012 \u2502 Cape Canaveral \u2502 \u2502 10 \u2502 cc_013 \u2502 Cape Canaveral \u2502 \u2502 11 \u2502 cc_014 \u2502 Cape Canaveral \u2502 \u2502 12 \u2502 cc_015 \u2502 Cape Canaveral \u2502 \u2502 13 \u2502 cc_016 \u2502 Cape Canaveral \u2502 \u2502 14 \u2502 cc_017 \u2502 Cape Canaveral \u2502 \u2502 15 \u2502 cc_018 \u2502 Cape Canaveral \u2502 \u2502 16 \u2502 cc_019 \u2502 Cape Canaveral \u2502 \u2502 17 \u2502 cc_020 \u2502 Cape Canaveral \u2502 \u2502 18 \u2502 cc_021 \u2502 Cape Canaveral \u2502 \u22ee \u2502 194 \u2502 seg_003 \u2502 Southeast Gulf \u2502 \u2502 195 \u2502 seg_009 \u2502 Southeast Gulf \u2502 \u2502 196 \u2502 seg_010 \u2502 Southeast Gulf \u2502 \u2502 197 \u2502 seg_011 \u2502 Southeast Gulf \u2502 \u2502 198 \u2502 seg_012 \u2502 Southeast Gulf \u2502 \u2502 199 \u2502 seg_014 \u2502 Southeast Gulf \u2502 \u2502 200 \u2502 seg_015 \u2502 Southeast Gulf \u2502 \u2502 201 \u2502 seg_016 \u2502 Southeast Gulf \u2502 \u2502 202 \u2502 seg_018 \u2502 Southeast Gulf \u2502 \u2502 203 \u2502 seg_021 \u2502 Southeast Gulf \u2502 \u2502 204 \u2502 seg_023 \u2502 Southeast Gulf \u2502 \u2502 205 \u2502 seg_024 \u2502 Southeast Gulf \u2502 \u2502 206 \u2502 seg_025 \u2502 Southeast Gulf \u2502 \u2502 207 \u2502 seg_026 \u2502 Southeast Gulf \u2502 \u2502 208 \u2502 seg_027 \u2502 Southeast Gulf \u2502 \u2502 209 \u2502 seg_028 \u2502 Southeast Gulf \u2502 \u2502 210 \u2502 seg_029 \u2502 Southeast Gulf \u2502 \u2502 211 \u2502 seg_030 \u2502 Southeast Gulf \u2502 \u2502 212 \u2502 seg_031 \u2502 Southeast Gulf \u2502","title":"rename populations"},{"location":"commands/#display-specific-loci-andor-samples","text":"","title":"display specific loci and/or samples"},{"location":"commands/#view-loci","text":"isolate_genotypes ( x :: PopObj ; samples = nothing , loci = nothing ) Default shows all genotypes for all individuals. Returns a DataFrame. all loci julia > isolate_genotypes ( sharks ) output 212\u00d72215 DataFrames.DataFrame. Omitted printing of 2209 columns \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 contig_10013 \u2502 contig_10028 \u2502 contig_10035 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026 \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (1, 1) \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 1) \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 (1, 2) \u2502 (2, 1) \u2502 (1, 1) \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 (1, 1) \u2502 (1, 2) \u2502 (2, 1) \u2502 (2, 1) \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 2) \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (2, 1) \u2502 (2, 2) \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 Add the argument loci= specify a single locus (string) or multiple loci (array of strings) to display single locus julia > isolate_genotypes ( sharks , loci = \"contig_10001\" ) single output 212\u00d73 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026 \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 (1, 1) \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 (1, 1) \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 (1, 1) \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 (1, 1) \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 (1, 1) \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 (1, 1) \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 (1, 1) \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 (1, 1) \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 (1, 1) \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 (1, 1) \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 (1, 1) \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 (1, 1) \u2502 multiple loci julia > isolate_genotypes ( sharks , loci = [ \"contig_10001\" , \"contig_10028\" ]) multiple output 212\u00d74 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 contig_10001 \u2502 contig_10028 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026 \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 (1, 1) \u2502 (2, 1) \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 (1, 1) \u2502 (1, 1) \u2502","title":"view loci"},{"location":"commands/#view-samples","text":"Add the argument samples= specify a single sample (string) or multiple samples (array of strings) to display single sample julia > isolate_genotypes ( sharks , samples = \"cc_001\" ) single output 1\u00d72215 DataFrames.DataFrame. Omitted printing of 2209 columns \u2502 Row \u2502 name \u2502 population \u2502 contig_10001 \u2502 contig_10013 \u2502 contig_10028 \u2502 contig_10035 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026\u2370 \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 (1, 1) \u2502 multiple samples 2 \u00d72215 DataFrames . DataFrame . Omitted printing of 2209 columns \u2502 Row \u2502 name \u2502 population \u2502 contig_10001 \u2502 contig_10013 \u2502 contig_10028 \u2502 contig_10035 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026\u2370 \u2502 Any \u2502 Any \u2502 Any \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 ( 1 , 1 ) \u2502 ( 1 , 1 ) \u2502 ( 1 , 1 ) \u2502 ( 1 , 1 ) \u2502 \u2502 2 \u2502 seg_028 \u2502 7 \u2502 ( 1 , 1 ) \u2502 ( 1 , 1 ) \u2502 ( 1 , 2 ) \u2502 ( 2 , 2 ) \u2502 It also means that you can combine the keywords samples= and loci= to further specify your output: both keywords isolate_genotypes ( sharks , samples = [ \"cc_001\" , \"seg_028\" ], loci = \"contig_10013\" ) output 2\u00d73 DataFrames.DataFrame \u2502 Row \u2502 name \u2502 population \u2502 contig_10013 \u2502 \u2502 \u2502 String \u2502 Categorical\u2026\u2370 \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 (1, 1) \u2502 \u2502 2 \u2502 seg_028 \u2502 7 \u2502 (1, 1) \u2502","title":"view samples"},{"location":"commands/#remove-loci","text":"remove_loci! ( x :: PopObj , loci :: Union { String , Array { String , 1 }}) Removes selected loci from a PopObj . Input can be a single locus, or an array of loci. Examples: single locus julia > remove_loci! ( sharks , \"contig_35208\" ) ; julia > summary ( sharks ) single output Object of type PopObj: Longitude: [\"-80.59928\", \"-80.59954\", \"-80.59958\"] \u2026 [\"-87.36617\", \"-85.71432\", \"-85.71432\"] Latitude: [\"28.30624\", \"28.30787\", \"28.30234\"] \u2026 [\"30.05217\", \"29.82344\", \"29.82344\"] Number of individuals: 212 [\"cc_001\", \"cc_002\", \"cc_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2212 [\"contig_23109\", \"contig_4493\", \"contig_10742\"] \u2026 [\"contig_19384\", \"contig_22368\", \"contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available .samples fields: .name, .population, .ploidy, .longitude, .latitude multiple loci julia > remove_loci! ( sharks , [ \"contig_35208\" , \"contig_23109\" , \"contig_4493\" ]) ; julia > summary ( sharks ) multiple output NOTICE: locus \"contig_35208\" not found Object of type PopObj: Longitude: [\"-80.59928\", \"-80.59954\", \"-80.59958\"] \u2026 [\"-87.36617\", \"-85.71432\", \"-85.71432\"] Latitude: [\"28.30624\", \"28.30787\", \"28.30234\"] \u2026 [\"30.05217\", \"29.82344\", \"29.82344\"] Number of individuals: 212 [\"cc_001\", \"cc_002\", \"cc_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2210 [\"contig_10742\", \"contig_14898\", \"contig_8483\"] \u2026 [\"contig_19384\", \"contig_22368\", \"contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available .samples fields: .name, .population, .ploidy, .longitude, .latitude locus not found! If removing a single locus and it is not found in the PopObj, an error will be returned. However, if removing multiple loci, you will receive a notice above the PopObj summary indicating which loci were not found, while removing the ones that were.","title":"remove loci"},{"location":"commands/#missing-data","text":"","title":"missing data"},{"location":"commands/#view-missing-data","text":"missing ( x :: PopObj ) Used to show missingness information-- that is, loci missing allele information. This command outputs two DataFrames, the first being a count of number of missing loci per samples, the other being the number of times a locus is missing across samples. missing julia > missing ( sharks ) output by_ind = (212\u00d74 DataFrames.DataFrame. Omitted printing of 1 columns \u2502 Row \u2502 name \u2502 population \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 124 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 94 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 100 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 0 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 2 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 1 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 2 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 0 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 0 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 0 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 2 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 25 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 0 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 1 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 1 \u2502, by_loci = 2213\u00d72 DataFrames.DataFrame \u2502 Row \u2502 locus \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0 \u2502 \u2502 2 \u2502 contig_23109 \u2502 6 \u2502 \u2502 3 \u2502 contig_4493 \u2502 3 \u2502 \u2502 4 \u2502 contig_10742 \u2502 2 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0 \u2502 \u2502 7 \u2502 contig_8065 \u2502 0 \u2502 \u22ee \u2502 2206 \u2502 contig_24711 \u2502 0 \u2502 \u2502 2207 \u2502 contig_18959 \u2502 0 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 6 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 2 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 5 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 3 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 7 \u2502) missing outputs a named tuple of dataframes, which means there are two options for assignment:","title":"view missing data"},{"location":"commands/#single-assignment","text":"The first DataFrame of the named tuple is named by_sample and the second named by_loci . If you assign a single variable to this tuple, it will inherit those names as accessors like so: single assignment julia > miss = missing ( sharks ) ; by_ind julia> miss.by_sample 212\u00d74 DataFrame. Omitted printing of 1 columns \u2502 Row \u2502 name \u2502 population \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 String \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 124 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 94 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 100 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 0 \u2502 \u22ee \u2502 208 \u2502 seg_027 \u2502 7 \u2502 2 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 25 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 0 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 1 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 1 \u2502 by_loci julia> miss.by_loci 2213\u00d72 DataFrame \u2502 Row \u2502 locus \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 Int64 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0 \u2502 \u2502 2 \u2502 contig_23109 \u2502 6 \u2502 \u2502 3 \u2502 contig_4493 \u2502 3 \u2502 \u2502 4 \u2502 contig_10742 \u2502 2 \u2502 \u22ee \u2502 2209 \u2502 contig_27356 \u2502 2 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 5 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 3 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 7 \u2502","title":"single assignment"},{"location":"commands/#multiple-assignment","text":"Python has this feature, however, if you're migrating from R, multiple assignment probably looks weird, or like flat-out sorcery. Whenever a function returns a tuple of values, like missing does, you can assign as many variables to it at once. missing julia > df1 , df2 = missing ( sharks ) ; df1 julia> df1 212\u00d74 DataFrames.DataFrame. Omitted printing of 1 columns \u2502 Row \u2502 name \u2502 population \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 124 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 94 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 100 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 0 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 2 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 1 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 2 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 0 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 0 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 0 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 2 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 25 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 0 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 1 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 1 \u2502 df2 julia> df2 2213\u00d72 DataFrames.DataFrame \u2502 Row \u2502 locus \u2502 nmissing \u2502 \u2502 \u2502 String \u2502 Any \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 contig_35208 \u2502 0 \u2502 \u2502 2 \u2502 contig_23109 \u2502 6 \u2502 \u2502 3 \u2502 contig_4493 \u2502 3 \u2502 \u2502 4 \u2502 contig_10742 \u2502 2 \u2502 \u2502 5 \u2502 contig_14898 \u2502 0 \u2502 \u2502 6 \u2502 contig_8483 \u2502 0 \u2502 \u2502 7 \u2502 contig_8065 \u2502 0 \u2502 \u22ee \u2502 2206 \u2502 contig_24711 \u2502 0 \u2502 \u2502 2207 \u2502 contig_18959 \u2502 0 \u2502 \u2502 2208 \u2502 contig_43517 \u2502 6 \u2502 \u2502 2209 \u2502 contig_27356 \u2502 2 \u2502 \u2502 2210 \u2502 contig_475 \u2502 0 \u2502 \u2502 2211 \u2502 contig_19384 \u2502 5 \u2502 \u2502 2212 \u2502 contig_22368 \u2502 3 \u2502 \u2502 2213 \u2502 contig_2784 \u2502 7 \u2502 a simple example If this still looks weird to you, here is a simple example to help wrap your mind around it. a , b , c , d = ( 1 , 2 , 3 ,[ 4 , 5 , 6 , 7 ]) where a = 1 b = 2 c = 3 d = [4, 5, 6, 7] embrace the convenience!","title":"multiple assignment"},{"location":"commands/#plot-missing-data","text":"plot_missing ( x :: PopObj ; color = false ) Return an interactive plot of the number of missing loci in individuals of a PopObj , along with the number of missing individuals per locus. Use color = [color1, color2, ...] to set a custom color palette for the boxplots. Example: julia > plot_missing ( sharks ) saving interactive plots To save the interactive plots, you can use the savehtml function from the PlotlyJS.jl package: PlotlyJS . savehtml ( plot , \"filename.html\" ) If you don't specify a full path in the filename, it will save it in your current working directory. #example julia > using PlotlyJS ; julia > PlotlyJS . savehtml ( plot_missing ( sharks ), \"/home/pdimens/missingness.html\" ) use a third argument :embed to make the plots fully viewable offline. The output files are much larger (relatively) because it embeds the Plotly javeascript into the file. For context, the gulfsharks plot file is ~3.5mb when using :embed","title":"plot missing data"},{"location":"commands/#location-data","text":"","title":"location data"},{"location":"commands/#view-location-data","text":"locations ( x :: PopObj ) View location data ( .longitude and .latitude ) in a PopObj If you want to do your own plotting, or just to look at the spatial data of your PopObj, this function is handy. It takes no additional arguments and outputs a DataFrame of individual names, population ID's, and their latitude/longitude information. locations julia > locations ( sharks ) output 212\u00d74 DataFrames.DataFrame \u2502 Row \u2502 ind \u2502 population \u2502 longitude \u2502 latitude \u2502 \u2502 \u2502 String \u2502 Union\u2026 \u2502 Union\u2026 \u2502 Union\u2026 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 cc_001 \u2502 1 \u2502 -80.5993 \u2502 28.3062 \u2502 \u2502 2 \u2502 cc_002 \u2502 1 \u2502 -80.5995 \u2502 28.3079 \u2502 \u2502 3 \u2502 cc_003 \u2502 1 \u2502 -80.5996 \u2502 28.3023 \u2502 \u2502 4 \u2502 cc_005 \u2502 1 \u2502 -80.4225 \u2502 28.6123 \u2502 \u2502 5 \u2502 cc_007 \u2502 1 \u2502 -80.3578 \u2502 27.8666 \u2502 \u2502 6 \u2502 cc_008 \u2502 1 \u2502 -80.3579 \u2502 27.8666 \u2502 \u2502 7 \u2502 cc_009 \u2502 1 \u2502 -80.3482 \u2502 27.8682 \u2502 \u22ee \u2502 205 \u2502 seg_024 \u2502 7 \u2502 -87.4403 \u2502 29.6966 \u2502 \u2502 206 \u2502 seg_025 \u2502 7 \u2502 -86.5374 \u2502 30.064 \u2502 \u2502 207 \u2502 seg_026 \u2502 7 \u2502 -86.5376 \u2502 30.0696 \u2502 \u2502 208 \u2502 seg_027 \u2502 7 \u2502 -86.0905 \u2502 29.9065 \u2502 \u2502 209 \u2502 seg_028 \u2502 7 \u2502 -87.3661 \u2502 30.0532 \u2502 \u2502 210 \u2502 seg_029 \u2502 7 \u2502 -87.3662 \u2502 30.0522 \u2502 \u2502 211 \u2502 seg_030 \u2502 7 \u2502 -85.7143 \u2502 29.8234 \u2502 \u2502 212 \u2502 seg_031 \u2502 7 \u2502 -85.7143 \u2502 29.8234 \u2502 locations secondary feature There is a built-in component in locations to test if the location data 1) exists, and 2) is of equal length, or it will spit out an error. It's probably a good idea to do this for your data at least once to be assured everything is ok!","title":"view location data"},{"location":"commands/#add-location-data","text":"Location data can be added by directly accessing the fields .longitude and .latitude in your PopObj , such as this example: julia > sharks . samples . longitude = rand ( 1 : 50 , 212 ) ; # creates 212 unique random numbers between 1 and 50 julia > sharks . samples . latitdue = rand ( 20 : 30 , 212 ) ; # creates 212 unique random numbers between 20 and 30 However, if your data is in decimal minutes rather than decimal degrees, use the locations! function to add it to the fields. This function will do a conversion from decimal minutes to decimal degrees for you. To import those data into Julia, you'll likely want to use the wonderful CSV.jl package first.","title":"add location data"},{"location":"commands/#decimal-minutes-data","text":"locations! ( x :: PopObj ; xloc :: Array , yloc :: Array ) Adds location data (longitude, latitude) to PopObj . Takes decimal degrees or decimal minutes format. Must use minus-sign instead of cardinal directions (i.e. 14 32.11W is not vaild). Location data must be in order of individuals ( ind ). Replaces existing PopObj location data. Decimal Degrees : -11.431 Decimal Minutes : \"-11 43.11\" (must use space and double-quotes) If conversion is not necessary, can directly assign PopObj.longitude and PopObj.latitude as shown above. If you still wanted to use locations! but don't need a conversion, it still works: julia > long = a . longitude = rand ( 1 : 50 , 212 ) ; julia > lat = a . latitdue = rand ( 20 : 30 , 212 ) ; julia > locations! ( a , long , lat ) ;","title":"decimal minutes data"},{"location":"commands/#plot-location-data","text":"plot_locations ( x :: PopObj , region = \"world\" , projection = \"orthogonal\" ) You're encouraged to plot locations how you see fit. For convenience and speed, we provide this command to make a decent, albeit simple interactive plot (Plotly) and save some time. There is a sizeable list of available map projections and regions if you look this function up in the help?> REPL prompt. julia > plot_locations ( sharks )","title":"plot location data"},{"location":"community/","text":"Join the Slack channel! Have questions, want to talk population genetics, or have ideas? Join the PopGen.jl Slack channel! \u2003 window.CommunityInviterAsyncInit = function () { \u2003 \u2003 CommunityInviter.init({ \u2003 \u2003 \u2003 app_url:'join', \u2003 \u2003 \u2003 team_id:'popgenjl' \u2003 \u2003}) \u2003 }; \u2003 (function(d, s, id){ \u2003 \u2003 var js, fjs = d.getElementsByTagName(s)[0]; \u2003 \u2003 if (d.getElementById(id)) {return;} \u2003 \u2003 js = d.createElement(s); js.id = id; \u2003 \u2003 js.src = \"https://communityinviter.com/js/communityinviter.js\"; \u2003 \u2003 fjs.parentNode.insertBefore(js, fjs); \u2003 }(document, 'script', 'Community_Inviter')); Contributing We absolutely welcome contributors to this package/project! Contributing can take the form of: Optimizing available code Pointing out bugs (and troubleshooting them if possible!) Testing your data against the available code Writing new functions or methods for existing functions Writing or editing the docs Spreading the word on social media Words of encouragement","title":"Community"},{"location":"community/#join-the-slack-channel","text":"Have questions, want to talk population genetics, or have ideas? Join the PopGen.jl Slack channel! \u2003 window.CommunityInviterAsyncInit = function () { \u2003 \u2003 CommunityInviter.init({ \u2003 \u2003 \u2003 app_url:'join', \u2003 \u2003 \u2003 team_id:'popgenjl' \u2003 \u2003}) \u2003 }; \u2003 (function(d, s, id){ \u2003 \u2003 var js, fjs = d.getElementsByTagName(s)[0]; \u2003 \u2003 if (d.getElementById(id)) {return;} \u2003 \u2003 js = d.createElement(s); js.id = id; \u2003 \u2003 js.src = \"https://communityinviter.com/js/communityinviter.js\"; \u2003 \u2003 fjs.parentNode.insertBefore(js, fjs); \u2003 }(document, 'script', 'Community_Inviter'));","title":"Join the Slack channel!"},{"location":"community/#contributing","text":"We absolutely welcome contributors to this package/project! Contributing can take the form of: Optimizing available code Pointing out bugs (and troubleshooting them if possible!) Testing your data against the available code Writing new functions or methods for existing functions Writing or editing the docs Spreading the word on social media Words of encouragement","title":"Contributing"},{"location":"delimited/","text":"Formatting Loci names must be first row Individuals names must be first value in row Population ID's must be second value in row Optional: longitude (x) values third value in row, latitude (y) fourth value in row Formatting examples without locations Locus1,Locus2,Locus3 sierra_01,1,001001,002002,001001 sierra_02,1,001001,001001,001002 snbarb_03,2,001001,001001,001002 snbarb_02,2,001001,001001,001001 snbarb_03,2,001002,001001,001001 with locations Locus1,Locus2,Locus3 sierra_01,1,14.1,15.2,001001,002002,001001 sierra_02,1,34.1,26.1,001001,001001,001002 snbarb_03,2,45.1,-11.2,001001,001001,001002 snbarb_02,2,-11.5,11.6,001001,001001,001001 snbarb_03,2,-3.1,43.2,001002,001001,001001 Import a CSV/delimited file as a PopObj Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\" csv ( infile ; delim , digits = 3 , location = false ) # Example julia > a = csv ( \"/data/cali_poppy.csv\" , delim = \",\" , digits = 3 ) Arguments infile :: String : path to the input file, in quotes Keyword Arguments delim :: Union { Char , String , Regex } : delimiter of the file, can be a string, character, or regex comma: delim = \",\" space: delim = \" \" tab: delim = \"\\t\" etc. digits :: Int64 : the number of digits used to denote an allele (default = 3) location :: Bool = false : true/false of whether location data is present in the file (default = false)","title":"CSV and delimited"},{"location":"delimited/#formatting","text":"Loci names must be first row Individuals names must be first value in row Population ID's must be second value in row Optional: longitude (x) values third value in row, latitude (y) fourth value in row","title":"Formatting"},{"location":"delimited/#formatting-examples","text":"without locations Locus1,Locus2,Locus3 sierra_01,1,001001,002002,001001 sierra_02,1,001001,001001,001002 snbarb_03,2,001001,001001,001002 snbarb_02,2,001001,001001,001001 snbarb_03,2,001002,001001,001001 with locations Locus1,Locus2,Locus3 sierra_01,1,14.1,15.2,001001,002002,001001 sierra_02,1,34.1,26.1,001001,001001,001002 snbarb_03,2,45.1,-11.2,001001,001001,001002 snbarb_02,2,-11.5,11.6,001001,001001,001001 snbarb_03,2,-3.1,43.2,001002,001001,001001","title":"Formatting examples"},{"location":"delimited/#import-a-csvdelimited-file-as-a-popobj","text":"Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\" csv ( infile ; delim , digits = 3 , location = false ) # Example julia > a = csv ( \"/data/cali_poppy.csv\" , delim = \",\" , digits = 3 )","title":"Import a CSV/delimited file as a PopObj"},{"location":"delimited/#arguments","text":"infile :: String : path to the input file, in quotes","title":"Arguments"},{"location":"delimited/#keyword-arguments","text":"delim :: Union { Char , String , Regex } : delimiter of the file, can be a string, character, or regex comma: delim = \",\" space: delim = \" \" tab: delim = \"\\t\" etc. digits :: Int64 : the number of digits used to denote an allele (default = 3) location :: Bool = false : true/false of whether location data is present in the file (default = false)","title":"Keyword Arguments"},{"location":"examples/","text":"PopGen.jl provides two datasets as examples, each with their own easy-to-remember function for retrieving those data. nancycats We include the familiar nancycats microsatellite data, as featured in adegenet , for easy importing into PopGen.jl as a PopObj . To use those data, simply invoke nancycats() without any arguments. julia> ncats = nancycats() ; summary(ncats) Object of type PopObj: No location data provided Number of individuals: 237 [\"N215\", \"N216\", \"N217\"] \u2026 [\"N281\", \"N289\", \"N290\"] Number of loci: 9 [\"fca8\", \"fca23\", \"fca43\"] \u2026 [\"fca90\", \"fca96\", \"fca37\"] Ploidy: 2 Number of populations: 17 #Inds | Pop -------------- 10 | 1 22 | 2 12 | 3 23 | 4 15 | 5 11 | 6 14 | 7 10 | 8 9 | 9 11 | 10 20 | 11 14 | 12 13 | 13 17 | 14 11 | 15 12 | 16 13 | 17 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude The spatial coordinates provided for the dataset in adegenet are completely unfamiliar to us (and some geospatial folks we spoke to), so they have been omitted. If you recognize what coordinate system has 485.111 appear in Nancy, France, please let us know! gulfsharks We also include the SNP dataset used in Dimens et al. 2019 \" A genomic assessment of movement and gene flow around the South Florida vicariance zone in the migratory coastal blacknose shark , Carcharhinus acronotus \" since it was already on hand. Like nancycats , we provide a convenient function to load these data into PopGen.jl as a PopObj . To use those data, simply invoke gulfsharks() without any arguments. julia> sharks = gulfsharks() ; summary(sharks) Object of type PopObj: Longitude: [\"-80.59928\", \"-80.59954\", \"-80.59958\"] \u2026 [\"-87.36617\", \"-85.71432\", \"-85.71432\"] Latitude: [\"28.30624\", \"28.30787\", \"28.30234\"] \u2026 [\"30.05217\", \"29.82344\", \"29.82344\"] Number of individuals: 212 [\"cc_001\", \"cc_002\", \"cc_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"contig_35208\", \"contig_23109\", \"contig_4493\"] \u2026 [\"contig_19384\", \"contig_22368\", \"contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude","title":"Example data"},{"location":"examples/#nancycats","text":"We include the familiar nancycats microsatellite data, as featured in adegenet , for easy importing into PopGen.jl as a PopObj . To use those data, simply invoke nancycats() without any arguments. julia> ncats = nancycats() ; summary(ncats) Object of type PopObj: No location data provided Number of individuals: 237 [\"N215\", \"N216\", \"N217\"] \u2026 [\"N281\", \"N289\", \"N290\"] Number of loci: 9 [\"fca8\", \"fca23\", \"fca43\"] \u2026 [\"fca90\", \"fca96\", \"fca37\"] Ploidy: 2 Number of populations: 17 #Inds | Pop -------------- 10 | 1 22 | 2 12 | 3 23 | 4 15 | 5 11 | 6 14 | 7 10 | 8 9 | 9 11 | 10 20 | 11 14 | 12 13 | 13 17 | 14 11 | 15 12 | 16 13 | 17 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude The spatial coordinates provided for the dataset in adegenet are completely unfamiliar to us (and some geospatial folks we spoke to), so they have been omitted. If you recognize what coordinate system has 485.111 appear in Nancy, France, please let us know!","title":"nancycats"},{"location":"examples/#gulfsharks","text":"We also include the SNP dataset used in Dimens et al. 2019 \" A genomic assessment of movement and gene flow around the South Florida vicariance zone in the migratory coastal blacknose shark , Carcharhinus acronotus \" since it was already on hand. Like nancycats , we provide a convenient function to load these data into PopGen.jl as a PopObj . To use those data, simply invoke gulfsharks() without any arguments. julia> sharks = gulfsharks() ; summary(sharks) Object of type PopObj: Longitude: [\"-80.59928\", \"-80.59954\", \"-80.59958\"] \u2026 [\"-87.36617\", \"-85.71432\", \"-85.71432\"] Latitude: [\"28.30624\", \"28.30787\", \"28.30234\"] \u2026 [\"30.05217\", \"29.82344\", \"29.82344\"] Number of individuals: 212 [\"cc_001\", \"cc_002\", \"cc_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"contig_35208\", \"contig_23109\", \"contig_4493\"] \u2026 [\"contig_19384\", \"contig_22368\", \"contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude","title":"gulfsharks"},{"location":"genepop/","text":"Format Files must follow standard Genepop formatting: First line is a comment (and skipped) Loci are listed after first line as one-per-line without commas or in single comma-separated row A line with a particular keyword must delimit populations Must be the same word each time and not a unique population name File is tab or space delimited Formatting Examples loci stacked vertically Wasp populations in New York Locus1 Locus2 Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120 loci stacked horizontally Wasp populations in New York Locus1,Locus2,Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120 Import a genepop file as a PopObj Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\" genepop ( infile ; digits = 3 , popsep = \"POP\" , numpops ) # Example julia > b = genepop ( \"/data/wasp_hive.gen\" , digits = 3 , popsep = \"POP\" , numpops = 2 ) Arguments infile::String : path to genepop file, in quotes Keyword Arguments digits::Int64 : the number of digits used to denote an allele (default = 3) popsep::String : word that separates populations in infile (default: \"POP\") numpops::Int64 : number of populations present in infile (used for early error checking) Default population names By default, the file reader will assign numbers as population ID's in order of appearance in the genepop file. Use the popid! function to rename these with your own population ID's.","title":"Genepop"},{"location":"genepop/#format","text":"Files must follow standard Genepop formatting: First line is a comment (and skipped) Loci are listed after first line as one-per-line without commas or in single comma-separated row A line with a particular keyword must delimit populations Must be the same word each time and not a unique population name File is tab or space delimited","title":"Format"},{"location":"genepop/#formatting-examples","text":"loci stacked vertically Wasp populations in New York Locus1 Locus2 Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120 loci stacked horizontally Wasp populations in New York Locus1,Locus2,Locus3 POP Oneida_01, 250230 564568 110100 Oneida_02, 252238 568558 100120 Oneida_03, 254230 564558 090100 POP Newcomb_01, 254230 564558 080100 Newcomb_02, 000230 564558 090080 Newcomb_03, 254230 000000 090100 Newcomb_04, 254230 564000 090120","title":"Formatting Examples"},{"location":"genepop/#import-a-genepop-file-as-a-popobj","text":"Windows users make sure to change your backslashes \"\\\" to forward slashes \"/\" genepop ( infile ; digits = 3 , popsep = \"POP\" , numpops ) # Example julia > b = genepop ( \"/data/wasp_hive.gen\" , digits = 3 , popsep = \"POP\" , numpops = 2 )","title":"Import a genepop file as a PopObj"},{"location":"genepop/#arguments","text":"infile::String : path to genepop file, in quotes","title":"Arguments"},{"location":"genepop/#keyword-arguments","text":"digits::Int64 : the number of digits used to denote an allele (default = 3) popsep::String : word that separates populations in infile (default: \"POP\") numpops::Int64 : number of populations present in infile (used for early error checking) Default population names By default, the file reader will assign numbers as population ID's in order of appearance in the genepop file. Use the popid! function to rename these with your own population ID's.","title":"Keyword Arguments"},{"location":"install/","text":"Installation Installing PopGen.jl The package is currently unregistered while it's under active early development. However, installation is still simple! Invoke the package manager with ] in the REPL and use add \"https://github.com/pdimens/PopGen.jl\" If using Jupyter Notebooks or nteract, install the package in julia with using Pkg Pkg . add ( \"https://github.com/pdimens/PopGen.jl\" ) Feel free to play around with the test data in /test/testdata.gen Using PopGen Like all Julia packages, to activate PopGen , simply run: julia > using PopGen Performance notes If you're migrating to Julia from Python or R (or Matlab, etc.), you'll think Julia is slow and laggy because loading packages and running stuff has a noticeable wait time (10-40sec). However, if this is your first time in Julia, then it's worth mentioning that this lag is \"compilation overhead\". What this means is, Julia tries to pre-compile as much code as possible (into optimized machine code) when running something or loading a package. This lag exists only the first time you run something. Every subsequent run of a function, even with different parameters, will be substantially faster, and in most cases instant. If you want to test this yourself, try to run a line of code twice with @time before the function and compare the results. Here's an example: julia> @time using PopGen 17.415902 seconds (19.88 M allocations: 1.022 GiB, 2.79% gc time) julia> @time using PopGen 0.100233 seconds (64.07 k allocations: 3.123 MiB, 6.02% gc time)","title":"Installing"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#installing-popgenjl","text":"The package is currently unregistered while it's under active early development. However, installation is still simple! Invoke the package manager with ] in the REPL and use add \"https://github.com/pdimens/PopGen.jl\" If using Jupyter Notebooks or nteract, install the package in julia with using Pkg Pkg . add ( \"https://github.com/pdimens/PopGen.jl\" ) Feel free to play around with the test data in /test/testdata.gen","title":"Installing PopGen.jl"},{"location":"install/#using-popgen","text":"Like all Julia packages, to activate PopGen , simply run: julia > using PopGen Performance notes If you're migrating to Julia from Python or R (or Matlab, etc.), you'll think Julia is slow and laggy because loading packages and running stuff has a noticeable wait time (10-40sec). However, if this is your first time in Julia, then it's worth mentioning that this lag is \"compilation overhead\". What this means is, Julia tries to pre-compile as much code as possible (into optimized machine code) when running something or loading a package. This lag exists only the first time you run something. Every subsequent run of a function, even with different parameters, will be substantially faster, and in most cases instant. If you want to test this yourself, try to run a line of code twice with @time before the function and compare the results. Here's an example: julia> @time using PopGen 17.415902 seconds (19.88 M allocations: 1.022 GiB, 2.79% gc time) julia> @time using PopGen 0.100233 seconds (64.07 k allocations: 3.123 MiB, 6.02% gc time)","title":"Using PopGen"},{"location":"juliaprimer/","text":"A quick Julia primer for getting the most out of this documentation There is nothing inherently special about this documentation relative to other documentation, other than we really really want you to get the most out of what's written here. This means that we need to embrace the fact that both novice and experienced Julia users may be reading these docs and using this package. So let's cover some Julia basics that will really help in navigating this package before we even get into the complicated genetics stuff. This primer is by no means \"everything you need to get started in Julia\", and is a poor substitute for actually learning the language. In general, we recommend Think Julia: How to Think Like a Data Scientist by Ben Lauwens to establish some solid Julia foundations. It's free online! Semicolons Semicolons will come up a lot in Julia, probably more than you would expect if you are migrating from another language. They mean different thing depending on where they are. At the end of a command When you see a semicolon after invoking a function, what that means is \"don't show me the output in the terminal window\". Example: julia > x = 2 + 2 4 julia > x = 10 + 2 ; julia > x 12 Julia will still process the command and assign 10 + 2 to x , but it won't show you the output in the terminal. We sometimes include a semicolon after commands in these docs to mimic what the REPL output would look like without spitting back out an array of over 200 values. These semicolons are optional In between assignment commands If you see a semicolon in between two variable assignments, like so: x = [ 1 , 2 ] ; y = [ 3 , 4 ] that's a Julia short-hand for making two short lines of code appear on a single line. It's the equivalent of doing: x = [ 1 , 2 ] y = [ 3 , 4 ] We sometimes choose this writing format for very quick and small assignments hoping to save some visual space. Use whichever method is most comfortable and sensible for you! Help mode To enter help mode in the REPL, simply press the question mark key ? (shift + key) and you will notice a different prompt help?> for you to type in a function. help ?> popid search: popid popid! popfirst! popdisplay precompile __precompile__ CompositeException popid(x::PopObj; listall::Bool = false) View unique population ID's in a PopObj. listall = true, displays ind and their popid instead (default = false). Type information Julia encourages strong typing of variables, and the functions in PopGen are no exception to this. However, to reduce the barrier of entry required to understand this documentation and the subsequent package, we have chosen to omit some of the type information from functions to reduce visual clutter for newer users. As experienced users already know, if you would like to see the explicit type information, you can look at the code on github, invoke the help system in the REPL (above), or search for a function in the Documentation pane in Juno. You'll notice types follow a specific format, which is object::type . This format is a type assignment, so in the function popid , which looks like: popid(x::PopObj; listall::Bool = false) : x is a variable of type PopObj listall is a variable of type Bool (boolean) meaning it only takes true or false without quotes Type Unions You might see the type Union appear occasionally throughout this documentation, and you can consider it a list of types. For example, if something was of type ::Union{String,Integer} , that means that either a String or Integer works. These kinds of Union appear in a few places, like remove_inds! , where the input can be either a String (a single individual) or an Array{String,1} (one-dimensional list of names). For remove_inds! , the second argument type appears as ::Union{String, Array{String,1}} . Also, the order in which types appear in Union types don't matter. Functions vs. Methods As part of Julia's type-safe paradigm and multiple dispatch (see \"ERROR: MethodError: no method matching\" below), type specifications in functions often reduce runtime of functions, but also establish function identity. Multiple dispatch refers to several different functions having the same name, but employing different methods depending on the input. In Julia, it's easier to write a single function with multiple type-safe methods, rather than one mega-function that accepts any type and have a bunch of if statements that determines what the program does depending on the input. In practice, this looks like: # combine two numbers julia> function add(x::Integer, y::Integer) x+y end add (generic function with 1 method) # combine two strings julia> function add(x::String, y::String) x*y end add (generic function with 2 methods) julia> add(1,2) 3 julia> add(\"water\", \"melon\") \"watermelon\" Multiple dispatch therefor leads to a unique type of possible error: the MethodError ERROR: MethodError: no method matching Using the function add from the example above, let's have a look at what happens when we try to add an Integer with a String : julia > add ( 1 , \"melon\" ) ERROR : MethodError : no method matching add ( :: Int64 , :: String ) Closest candidates are : add ( :: String , :: String ) at none : 2 add ( :: Integer , :: Integer ) at none : 2 Stacktrace : [ 1 ] top - level scope at none : 0 This error is telling us \"there is no such function called add , who's inputs are an Integer followed by a String \". But, it does offer us some alternatives, like the two add functions we created earlier. The functions within PopGen are almost always explicitly typed, so if you are getting the MethodError: no method matching error, then you are inputting the incorrect types into the function, or perhaps your inputs for the arguments are in the wrong order (see \"Functions with and without keywords\" below). keep in mind MethodError's can definitely get annoying, but they are usually the result of incorrect input from the user and not buggy programming by the developers. Please take that into consideration before assuming something is broken or bugged. Functions with and without keywords TL;DR Reading these docs, pay attention to semicolons in the function argument lists. arguments before a semicolon have no keyword and follow an explicit order arguments after a semicolon have a keyword argument = value and their order doesn't matter MethodError: no methods matching is more likely an issue on your side and not on our side unless we accidentally forgot to export a function! Broadly speaking, there are two types of function declarations in Julia: ones with keywords and ones without keywords. The term \"keywords\" refers to an input argument that has the format argument = value . This format is present in many of the functions in this and other packages, however there are some specifics to understand when functions use keywords and when they don't. Format 1: Strict argument order and no keywords - No semicolon in argument list function function_name ( var1 :: type , var2 :: type , var3 :: type ) do stuff with vars end If a function is declared with only commas in the argument list, like shown above, then the arguments to that function must have no keywords and follow the exact order they appear in. If the generic example above had the typing: function function_name ( var1 :: String , var2 :: Float64 , var3 :: Array { String , 1 }) do stuff with vars end then the only acceptable way to run this function without getting a MethodError would be with arguments in the order of function_name(String, Float64, Array{String,1}) . Even if some of the arguments have a default values, like var2::Float64 = 6.66 , the order of arguments/types has to be respected as declared. Format 2 - semicolon in argument list function function_name ( var1 :: type ; var2 :: type , var3 :: type ) do stuff with vars end In this format, everything that comes before the semicolon follows the strict rules from Format 1 , and everything that comes after the semicolon is a keyword argument. Keyword arguments have the flexibility to not require any particular input order. However, you must use the keywords to declare those arguments, or you will receive another MethodError: no method matching , which is, as we've mentioned, annoying.","title":"Getting started"},{"location":"juliaprimer/#a-quick-julia-primer-for-getting-the-most-out-of-this-documentation","text":"There is nothing inherently special about this documentation relative to other documentation, other than we really really want you to get the most out of what's written here. This means that we need to embrace the fact that both novice and experienced Julia users may be reading these docs and using this package. So let's cover some Julia basics that will really help in navigating this package before we even get into the complicated genetics stuff. This primer is by no means \"everything you need to get started in Julia\", and is a poor substitute for actually learning the language. In general, we recommend Think Julia: How to Think Like a Data Scientist by Ben Lauwens to establish some solid Julia foundations. It's free online!","title":"A quick Julia primer for getting the most out of this documentation"},{"location":"juliaprimer/#semicolons","text":"Semicolons will come up a lot in Julia, probably more than you would expect if you are migrating from another language. They mean different thing depending on where they are.","title":"Semicolons"},{"location":"juliaprimer/#at-the-end-of-a-command","text":"When you see a semicolon after invoking a function, what that means is \"don't show me the output in the terminal window\". Example: julia > x = 2 + 2 4 julia > x = 10 + 2 ; julia > x 12 Julia will still process the command and assign 10 + 2 to x , but it won't show you the output in the terminal. We sometimes include a semicolon after commands in these docs to mimic what the REPL output would look like without spitting back out an array of over 200 values. These semicolons are optional","title":"At the end of a command"},{"location":"juliaprimer/#in-between-assignment-commands","text":"If you see a semicolon in between two variable assignments, like so: x = [ 1 , 2 ] ; y = [ 3 , 4 ] that's a Julia short-hand for making two short lines of code appear on a single line. It's the equivalent of doing: x = [ 1 , 2 ] y = [ 3 , 4 ] We sometimes choose this writing format for very quick and small assignments hoping to save some visual space. Use whichever method is most comfortable and sensible for you!","title":"In between assignment commands"},{"location":"juliaprimer/#help-mode","text":"To enter help mode in the REPL, simply press the question mark key ? (shift + key) and you will notice a different prompt help?> for you to type in a function. help ?> popid search: popid popid! popfirst! popdisplay precompile __precompile__ CompositeException popid(x::PopObj; listall::Bool = false) View unique population ID's in a PopObj. listall = true, displays ind and their popid instead (default = false).","title":"Help mode"},{"location":"juliaprimer/#type-information","text":"Julia encourages strong typing of variables, and the functions in PopGen are no exception to this. However, to reduce the barrier of entry required to understand this documentation and the subsequent package, we have chosen to omit some of the type information from functions to reduce visual clutter for newer users. As experienced users already know, if you would like to see the explicit type information, you can look at the code on github, invoke the help system in the REPL (above), or search for a function in the Documentation pane in Juno. You'll notice types follow a specific format, which is object::type . This format is a type assignment, so in the function popid , which looks like: popid(x::PopObj; listall::Bool = false) : x is a variable of type PopObj listall is a variable of type Bool (boolean) meaning it only takes true or false without quotes","title":"Type information"},{"location":"juliaprimer/#type-unions","text":"You might see the type Union appear occasionally throughout this documentation, and you can consider it a list of types. For example, if something was of type ::Union{String,Integer} , that means that either a String or Integer works. These kinds of Union appear in a few places, like remove_inds! , where the input can be either a String (a single individual) or an Array{String,1} (one-dimensional list of names). For remove_inds! , the second argument type appears as ::Union{String, Array{String,1}} . Also, the order in which types appear in Union types don't matter.","title":"Type Unions"},{"location":"juliaprimer/#functions-vs-methods","text":"As part of Julia's type-safe paradigm and multiple dispatch (see \"ERROR: MethodError: no method matching\" below), type specifications in functions often reduce runtime of functions, but also establish function identity. Multiple dispatch refers to several different functions having the same name, but employing different methods depending on the input. In Julia, it's easier to write a single function with multiple type-safe methods, rather than one mega-function that accepts any type and have a bunch of if statements that determines what the program does depending on the input. In practice, this looks like: # combine two numbers julia> function add(x::Integer, y::Integer) x+y end add (generic function with 1 method) # combine two strings julia> function add(x::String, y::String) x*y end add (generic function with 2 methods) julia> add(1,2) 3 julia> add(\"water\", \"melon\") \"watermelon\" Multiple dispatch therefor leads to a unique type of possible error: the MethodError","title":"Functions vs. Methods"},{"location":"juliaprimer/#error-methoderror-no-method-matching","text":"Using the function add from the example above, let's have a look at what happens when we try to add an Integer with a String : julia > add ( 1 , \"melon\" ) ERROR : MethodError : no method matching add ( :: Int64 , :: String ) Closest candidates are : add ( :: String , :: String ) at none : 2 add ( :: Integer , :: Integer ) at none : 2 Stacktrace : [ 1 ] top - level scope at none : 0 This error is telling us \"there is no such function called add , who's inputs are an Integer followed by a String \". But, it does offer us some alternatives, like the two add functions we created earlier. The functions within PopGen are almost always explicitly typed, so if you are getting the MethodError: no method matching error, then you are inputting the incorrect types into the function, or perhaps your inputs for the arguments are in the wrong order (see \"Functions with and without keywords\" below). keep in mind MethodError's can definitely get annoying, but they are usually the result of incorrect input from the user and not buggy programming by the developers. Please take that into consideration before assuming something is broken or bugged.","title":"ERROR: MethodError: no method matching"},{"location":"juliaprimer/#functions-with-and-without-keywords","text":"TL;DR Reading these docs, pay attention to semicolons in the function argument lists. arguments before a semicolon have no keyword and follow an explicit order arguments after a semicolon have a keyword argument = value and their order doesn't matter MethodError: no methods matching is more likely an issue on your side and not on our side unless we accidentally forgot to export a function! Broadly speaking, there are two types of function declarations in Julia: ones with keywords and ones without keywords. The term \"keywords\" refers to an input argument that has the format argument = value . This format is present in many of the functions in this and other packages, however there are some specifics to understand when functions use keywords and when they don't.","title":"Functions with and without keywords"},{"location":"juliaprimer/#format-1-strict-argument-order-and-no-keywords-no-semicolon-in-argument-list","text":"function function_name ( var1 :: type , var2 :: type , var3 :: type ) do stuff with vars end If a function is declared with only commas in the argument list, like shown above, then the arguments to that function must have no keywords and follow the exact order they appear in. If the generic example above had the typing: function function_name ( var1 :: String , var2 :: Float64 , var3 :: Array { String , 1 }) do stuff with vars end then the only acceptable way to run this function without getting a MethodError would be with arguments in the order of function_name(String, Float64, Array{String,1}) . Even if some of the arguments have a default values, like var2::Float64 = 6.66 , the order of arguments/types has to be respected as declared.","title":"Format 1: Strict argument order and no keywords - No semicolon in argument list"},{"location":"juliaprimer/#format-2-semicolon-in-argument-list","text":"function function_name ( var1 :: type ; var2 :: type , var3 :: type ) do stuff with vars end In this format, everything that comes before the semicolon follows the strict rules from Format 1 , and everything that comes after the semicolon is a keyword argument. Keyword arguments have the flexibility to not require any particular input order. However, you must use the keywords to declare those arguments, or you will receive another MethodError: no method matching , which is, as we've mentioned, annoying.","title":"Format 2 - semicolon in argument list"},{"location":"popobj_location/","text":"Location Data Notice the No location data provided text on the second line of output when you show a PopObj , like demonstrated on the previous page. That text exists as a \"heads up\" rather than a warning because location data is optional for a PopObj . There are functions that use location information (e.g. locations and plot_locations ), but most don't, so it's not a dealbreaker. If you add location information, displaying the PopObj again will show you output now including this information: julia> a = gulfsharks() ; summary(a) Object of type PopObj: Longitude: [\"26\", \"7\", \"21\"] \u2026 [\"25\", \"26\", \"29\"] Latitude: [\"10\", \"10\", \"40\"] \u2026 [\"3\", \"5\", \"46\"] Number of individuals: 212 [\"cca_001\", \"cca_002\", \"cca_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"Contig_35208\", \"Contig_23109\", \"Contig_4493\"] \u2026 [\"Contig_19384\", \"Contig_22368\", \"Contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude Info While showing a PopObj represents location data as strings, they are actually coded as integers or floating point numbers. This was a design decision to remove visual clutter, however we can easily revert it back to displaying Int or Float64 with type information if that's what users prefer.","title":"Location data"},{"location":"popobj_location/#location-data","text":"Notice the No location data provided text on the second line of output when you show a PopObj , like demonstrated on the previous page. That text exists as a \"heads up\" rather than a warning because location data is optional for a PopObj . There are functions that use location information (e.g. locations and plot_locations ), but most don't, so it's not a dealbreaker. If you add location information, displaying the PopObj again will show you output now including this information: julia> a = gulfsharks() ; summary(a) Object of type PopObj: Longitude: [\"26\", \"7\", \"21\"] \u2026 [\"25\", \"26\", \"29\"] Latitude: [\"10\", \"10\", \"40\"] \u2026 [\"3\", \"5\", \"46\"] Number of individuals: 212 [\"cca_001\", \"cca_002\", \"cca_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"Contig_35208\", \"Contig_23109\", \"Contig_4493\"] \u2026 [\"Contig_19384\", \"Contig_22368\", \"Contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude Info While showing a PopObj represents location data as strings, they are actually coded as integers or floating point numbers. This was a design decision to remove visual clutter, however we can easily revert it back to displaying Int or Float64 with type information if that's what users prefer.","title":"Location Data"},{"location":"popobj_type/","text":"For the PopGen.jl package to be consistent, a standard flexible data structure needs to be defined. The solution is a custom type called a PopObj . The struct is defined as: mutable struct PopObj samples :: DataFrame loci :: DataFrame end pronouncing \"PopObj\" If you haven't already guessed, PopObj is a combination of the words Population and Object. PopObj is pronounced \"pop ob\" with a silent j because it rolls of the tongue better, but writing it as PopOb looks weird. Yes, I have lost sleep over this detail. - Pavel As you can see, a PopObj is made up of two dataframes, one for sample information, the other for genotype information. This structure allows for easy and convenient access to the fields using dot . accessors. avoid manual creation While it may seem simple enough to create two dataframes and make a PopObj out of them, the structure of samples and loci are specific, so small mistakes in creating them can create many errors and prevent PopGen from working correctly on your data. Please use the included csv , genepop , and vcf file importers instead. samples The samples dataframe has 5 specific categories: name, population, ploidy, latitude, longitude. samples.name ::Array{String,1} The individual/sample names [ \"ind_001\" , \"ind_002\" , \"ind_003\" ] samples.population ::Array{String,1} The individual/sample population ID's [ \"borneo\" , \"borneo\" , \"new jersey\" ] samples.ploidy ::Array{Int8,1} The ploidy of the samples [ 2 , 2 , 2 ] samples.latitude ::Array{Union{Int64,Float64},1} latitude data of samples (decimal degrees) [-11.12, 15.32, 11.02, -4] samples.longitude ::Array{Union{Int64,Float64},1} longitude data of samples (decimal degrees) [-11.12, 15.32, 11.02, -4] loci The genotype information is stored in a separate dataframe called loci , where each column is named for the locus it represents. This makes for easy and obvious accessing by calling PopObj.loci.locusname . To view the loci names, use the convenient loci_names command. genotypes ::Array{Tuple{Int16,...},1} The genotypes of the loci are an array of tuples, with each value corresponding to an allele. The length of the tuple will vary based on the ploidy of the sample, therefor the type shown above is conceptually accurate, but computationally incorrect. [(0,1),(0,0),(1,2)] Important We use the tuple type for genotypes of individuals because they are immutable (cannot be changed). By the time you're using PopGen.jl , your data should already be filtered and screened. Hand-editing of genotype values is strongly discouraged, so we outlawed it outright. Viewing a PopObj Given the volume of information that can be present in a PopObj , we recommend summary() to summarize/overview the data rather than regurgitate everything on the screen. julia> a = gulfsharks() ; julia> summary(a) Object of type PopObj: No location data provided Number of individuals: 212 [\"cca_001\", \"cca_002\", \"cca_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"Contig_35208\", \"Contig_23109\", \"Contig_4493\"] \u2026 [\"Contig_19384\", \"Contig_22368\", \"Contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude","title":"What's a PopObj"},{"location":"popobj_type/#samples","text":"The samples dataframe has 5 specific categories: name, population, ploidy, latitude, longitude.","title":"samples"},{"location":"popobj_type/#samplesname","text":"::Array{String,1} The individual/sample names [ \"ind_001\" , \"ind_002\" , \"ind_003\" ]","title":"samples.name"},{"location":"popobj_type/#samplespopulation","text":"::Array{String,1} The individual/sample population ID's [ \"borneo\" , \"borneo\" , \"new jersey\" ]","title":"samples.population"},{"location":"popobj_type/#samplesploidy","text":"::Array{Int8,1} The ploidy of the samples [ 2 , 2 , 2 ]","title":"samples.ploidy"},{"location":"popobj_type/#sampleslatitude","text":"::Array{Union{Int64,Float64},1} latitude data of samples (decimal degrees) [-11.12, 15.32, 11.02, -4]","title":"samples.latitude"},{"location":"popobj_type/#sampleslongitude","text":"::Array{Union{Int64,Float64},1} longitude data of samples (decimal degrees) [-11.12, 15.32, 11.02, -4]","title":"samples.longitude"},{"location":"popobj_type/#loci","text":"The genotype information is stored in a separate dataframe called loci , where each column is named for the locus it represents. This makes for easy and obvious accessing by calling PopObj.loci.locusname . To view the loci names, use the convenient loci_names command.","title":"loci"},{"location":"popobj_type/#genotypes","text":"::Array{Tuple{Int16,...},1} The genotypes of the loci are an array of tuples, with each value corresponding to an allele. The length of the tuple will vary based on the ploidy of the sample, therefor the type shown above is conceptually accurate, but computationally incorrect. [(0,1),(0,0),(1,2)] Important We use the tuple type for genotypes of individuals because they are immutable (cannot be changed). By the time you're using PopGen.jl , your data should already be filtered and screened. Hand-editing of genotype values is strongly discouraged, so we outlawed it outright.","title":"genotypes"},{"location":"popobj_type/#viewing-a-popobj","text":"Given the volume of information that can be present in a PopObj , we recommend summary() to summarize/overview the data rather than regurgitate everything on the screen. julia> a = gulfsharks() ; julia> summary(a) Object of type PopObj: No location data provided Number of individuals: 212 [\"cca_001\", \"cca_002\", \"cca_003\"] \u2026 [\"seg_029\", \"seg_030\", \"seg_031\"] Number of loci: 2213 [\"Contig_35208\", \"Contig_23109\", \"Contig_4493\"] \u2026 [\"Contig_19384\", \"Contig_22368\", \"Contig_2784\"] Ploidy: 2 Number of populations: 7 #Inds | Pop -------------- 21 | 1 30 | 2 28 | 3 65 | 4 28 | 5 20 | 6 20 | 7 Available fields: ind, popid, loci, ploidy, genotypes, longitude, latitude","title":"Viewing a PopObj"},{"location":"vcf/","text":"Format Variant Call Format (or VCF ) files already follow a format standard, and while there is some wiggle-room for optional values, PopGen.jl only requires the core/mandatory components of a VCF, meaning problems should hopefully not arise regardless of which variant caller you are using (although we use Freebayes ourselves). Please open an issue if they do, or reach out to us on the community Slack. filter VCF files beforehand Keep in mind, VCF files need to be filtered before importing them into PopGen.jl. There is no and will be no VCF-filtering functionality to this package, as it is outside of the purpose of PopGen.jl. Refer to vcftools and vcflib to filter your sequence data. Import a VCF file as a PopObj PopGen.jl provides a simple command vcf to import a VCF file as a PopObj , which requires only the name of the file and nothing else. potato = vcf ( \"/home/data/russet_potatoes.vcf\" ) What VCF files lack Due to the nature of the file format, importing VCF files will provide: sample names ploidy of each sample locus names genotypes but they will not provide: population information latitude or longitude This means you will need to add that information separately afterwards. Location data (which is optional!) can be added to the PopObj directly with .samples.latitude or .samples.longitude or with the locations! command. Population names (mandatory!) can be added by overwriting .samples.population with an array of population names.","title":"VCF"},{"location":"vcf/#format","text":"Variant Call Format (or VCF ) files already follow a format standard, and while there is some wiggle-room for optional values, PopGen.jl only requires the core/mandatory components of a VCF, meaning problems should hopefully not arise regardless of which variant caller you are using (although we use Freebayes ourselves). Please open an issue if they do, or reach out to us on the community Slack. filter VCF files beforehand Keep in mind, VCF files need to be filtered before importing them into PopGen.jl. There is no and will be no VCF-filtering functionality to this package, as it is outside of the purpose of PopGen.jl. Refer to vcftools and vcflib to filter your sequence data.","title":"Format"},{"location":"vcf/#import-a-vcf-file-as-a-popobj","text":"PopGen.jl provides a simple command vcf to import a VCF file as a PopObj , which requires only the name of the file and nothing else. potato = vcf ( \"/home/data/russet_potatoes.vcf\" )","title":"Import a VCF file as a PopObj"},{"location":"vcf/#what-vcf-files-lack","text":"Due to the nature of the file format, importing VCF files will provide: sample names ploidy of each sample locus names genotypes but they will not provide: population information latitude or longitude This means you will need to add that information separately afterwards. Location data (which is optional!) can be added to the PopObj directly with .samples.latitude or .samples.longitude or with the locations! command. Population names (mandatory!) can be added by overwriting .samples.population with an array of population names.","title":"What VCF files lack"}]}